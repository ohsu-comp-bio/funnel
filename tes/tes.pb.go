// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tes.proto

/*
Package tes is a generated protocol buffer package.

It is generated from these files:
	tes.proto

It has these top-level messages:
	Task
	Input
	Output
	Executor
	Resources
	TaskLog
	ExecutorLog
	OutputFileLog
	CreateTaskResponse
	GetTaskRequest
	ListTasksRequest
	ListTasksResponse
	CancelTaskRequest
	CancelTaskResponse
	ServiceInfoRequest
	ServiceInfo
*/
package tes

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FileType int32

const (
	FileType_FILE      FileType = 0
	FileType_DIRECTORY FileType = 1
)

var FileType_name = map[int32]string{
	0: "FILE",
	1: "DIRECTORY",
}
var FileType_value = map[string]int32{
	"FILE":      0,
	"DIRECTORY": 1,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}
func (FileType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// OUTPUT ONLY
//
// Task states.
type State int32

const (
	// The state of the task is unknown.
	//
	// This provides a safe default for messages where this field is missing,
	// for example, so that a missing field does not accidentally imply that
	// the state is QUEUED.
	State_UNKNOWN State = 0
	// The task is queued.
	State_QUEUED State = 1
	// The task has been assigned to a worker and is currently preparing to run.
	// For example, the worker may be turning on, downloading input files, etc.
	State_INITIALIZING State = 2
	// The task is running. Input files are downloaded and the first Executor
	// has been started.
	State_RUNNING State = 3
	// The task is paused.
	//
	// An implementation may have the ability to pause a task, but this is not required.
	State_PAUSED State = 4
	// The task has completed running. Executors have exited without error
	// and output files have been successfully uploaded.
	State_COMPLETE State = 5
	// The task encountered an error in one of the Executor processes. Generally,
	// this means that an Executor exited with a non-zero exit code.
	State_EXECUTOR_ERROR State = 6
	// The task was stopped due to a system error, but not from an Executor,
	// for example an upload failed due to network issues, the worker's ran out
	// of disk space, etc.
	State_SYSTEM_ERROR State = 7
	// The task was canceled by the user.
	State_CANCELED State = 8
)

var State_name = map[int32]string{
	0: "UNKNOWN",
	1: "QUEUED",
	2: "INITIALIZING",
	3: "RUNNING",
	4: "PAUSED",
	5: "COMPLETE",
	6: "EXECUTOR_ERROR",
	7: "SYSTEM_ERROR",
	8: "CANCELED",
}
var State_value = map[string]int32{
	"UNKNOWN":        0,
	"QUEUED":         1,
	"INITIALIZING":   2,
	"RUNNING":        3,
	"PAUSED":         4,
	"COMPLETE":       5,
	"EXECUTOR_ERROR": 6,
	"SYSTEM_ERROR":   7,
	"CANCELED":       8,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// TaskView affects the fields returned by the ListTasks endpoint.
//
// Some of the fields in task can be large strings (e.g. logs),
// which can be a burden on the network. In the default BASIC view,
// these heavyweight fields are not included, however, a client may
// request the FULL version to include these fields.
type TaskView int32

const (
	// Task message will include ONLY the fields:
	//   Task.Id
	//   Task.State
	TaskView_MINIMAL TaskView = 0
	// Task message will include all fields EXCEPT:
	//   Task.ExecutorLog.stdout
	//   Task.ExecutorLog.stderr
	//   Input.content
	//   TaskLog.system_logs
	TaskView_BASIC TaskView = 1
	// Task message includes all fields.
	TaskView_FULL TaskView = 2
)

var TaskView_name = map[int32]string{
	0: "MINIMAL",
	1: "BASIC",
	2: "FULL",
}
var TaskView_value = map[string]int32{
	"MINIMAL": 0,
	"BASIC":   1,
	"FULL":    2,
}

func (x TaskView) String() string {
	return proto.EnumName(TaskView_name, int32(x))
}
func (TaskView) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Task describes an instance of a task.
type Task struct {
	// OUTPUT ONLY
	//
	// Task identifier assigned by the server.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// OUTPUT ONLY
	State State `protobuf:"varint,2,opt,name=state,enum=tes.State" json:"state,omitempty"`
	// OPTIONAL
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	Description string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// OPTIONAL
	//
	// Input files.
	// Inputs will be downloaded and mounted into the executor container.
	Inputs []*Input `protobuf:"bytes,6,rep,name=inputs" json:"inputs,omitempty"`
	// OPTIONAL
	//
	// Output files.
	// Outputs will be uploaded from the executor container to long-term storage.
	Outputs []*Output `protobuf:"bytes,7,rep,name=outputs" json:"outputs,omitempty"`
	// OPTIONAL
	//
	// Request that the task be run with these resources.
	Resources *Resources `protobuf:"bytes,8,opt,name=resources" json:"resources,omitempty"`
	// REQUIRED
	//
	// A list of executors to be run, sequentially. Execution stops
	// on the first error.
	Executors []*Executor `protobuf:"bytes,9,rep,name=executors" json:"executors,omitempty"`
	// OPTIONAL
	//
	// Volumes are directories which may be used to share data between
	// Executors. Volumes are initialized as empty directories by the
	// system when the task starts and are mounted at the same path
	// in each Executor.
	//
	// For example, given a volume defined at "/vol/A",
	// executor 1 may write a file to "/vol/A/exec1.out.txt", then
	// executor 2 may read from that file.
	//
	// (Essentially, this translates to a `docker run -v` flag where
	// the container path is the same for each executor).
	Volumes []string `protobuf:"bytes,10,rep,name=volumes" json:"volumes,omitempty"`
	// OPTIONAL
	//
	// A key-value map of arbitrary tags.
	Tags map[string]string `protobuf:"bytes,11,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// OUTPUT ONLY
	//
	// Task logging information.
	// Normally, this will contain only one entry, but in the case where
	// a task fails and is retried, an entry will be appended to this list.
	Logs []*TaskLog `protobuf:"bytes,12,rep,name=logs" json:"logs,omitempty"`
	// OUTPUT ONLY, REQUIRED
	//
	// Date + time the task was created, in RFC 3339 format.
	// This is set by the system, not the client.
	CreationTime string `protobuf:"bytes,13,opt,name=creation_time,json=creationTime" json:"creation_time,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Task) GetState() State {
	if m != nil {
		return m.State
	}
	return State_UNKNOWN
}

func (m *Task) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Task) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Task) GetInputs() []*Input {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Task) GetOutputs() []*Output {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Task) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Task) GetExecutors() []*Executor {
	if m != nil {
		return m.Executors
	}
	return nil
}

func (m *Task) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Task) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Task) GetLogs() []*TaskLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *Task) GetCreationTime() string {
	if m != nil {
		return m.CreationTime
	}
	return ""
}

// Input describes Task input files.
type Input struct {
	// OPTIONAL
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// REQUIRED, unless "content" is set.
	//
	// URL in long term storage, for example:
	// s3://my-object-store/file1
	// gs://my-bucket/file2
	// file:///path/to/my/file
	// /path/to/my/file
	// etc...
	Url string `protobuf:"bytes,3,opt,name=url" json:"url,omitempty"`
	// REQUIRED
	//
	// Path of the file inside the container.
	// Must be an absolute path.
	Path string `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	//
	// Type of the file, FILE or DIRECTORY
	Type FileType `protobuf:"varint,5,opt,name=type,enum=tes.FileType" json:"type,omitempty"`
	// OPTIONAL
	//
	// File content literal.
	// Implementations should support a minimum of 128 KiB in this field and may define its own maximum.
	// UTF-8 encoded
	//
	// If content is not empty, "url" must be ignored.
	Content string `protobuf:"bytes,6,opt,name=content" json:"content,omitempty"`
}

func (m *Input) Reset()                    { *m = Input{} }
func (m *Input) String() string            { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()               {}
func (*Input) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Input) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Input) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Input) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Input) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Input) GetType() FileType {
	if m != nil {
		return m.Type
	}
	return FileType_FILE
}

func (m *Input) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// Output describes Task output files.
type Output struct {
	// OPTIONAL
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// REQUIRED
	//
	// URL in long term storage, for example:
	// s3://my-object-store/file1
	// gs://my-bucket/file2
	// file:///path/to/my/file
	// /path/to/my/file
	// etc...
	Url string `protobuf:"bytes,3,opt,name=url" json:"url,omitempty"`
	// REQUIRED
	//
	// Path of the file inside the container.
	// Must be an absolute path.
	Path string `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	//
	// Type of the file, FILE or DIRECTORY
	Type FileType `protobuf:"varint,5,opt,name=type,enum=tes.FileType" json:"type,omitempty"`
}

func (m *Output) Reset()                    { *m = Output{} }
func (m *Output) String() string            { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()               {}
func (*Output) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Output) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Output) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Output) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Output) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Output) GetType() FileType {
	if m != nil {
		return m.Type
	}
	return FileType_FILE
}

// Executor describes a command to be executed, and its environment.
type Executor struct {
	// REQUIRED
	//
	// Name of the container image, for example:
	// ubuntu
	// quay.io/aptible/ubuntu
	// gcr.io/my-org/my-image
	// etc...
	Image string `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
	// REQUIRED
	//
	// A sequence of program arguments to execute, where the first argument
	// is the program to execute (i.e. argv).
	Command []string `protobuf:"bytes,2,rep,name=command" json:"command,omitempty"`
	// OPTIONAL
	//
	// The working directory that the command will be executed in.
	// Defaults to the directory set by the container image.
	Workdir string `protobuf:"bytes,3,opt,name=workdir" json:"workdir,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file which will be piped
	// to the executor's stdin. Must be an absolute path.
	Stdin string `protobuf:"bytes,6,opt,name=stdin" json:"stdin,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file where the executor's
	// stdout will be written to. Must be an absolute path.
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file where the executor's
	// stderr will be written to. Must be an absolute path.
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
	// OPTIONAL
	//
	// Enviromental variables to set within the container.
	Env map[string]string `protobuf:"bytes,8,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Executor) Reset()                    { *m = Executor{} }
func (m *Executor) String() string            { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()               {}
func (*Executor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Executor) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Executor) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Executor) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *Executor) GetStdin() string {
	if m != nil {
		return m.Stdin
	}
	return ""
}

func (m *Executor) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *Executor) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *Executor) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

// Resources describes the resources requested by a task.
type Resources struct {
	// OPTIONAL
	//
	// Requested number of CPUs
	CpuCores uint32 `protobuf:"varint,1,opt,name=cpu_cores,json=cpuCores" json:"cpu_cores,omitempty"`
	// OPTIONAL
	//
	// Is the task allowed to run on preemptible compute instances (e.g. AWS Spot)?
	Preemptible bool `protobuf:"varint,2,opt,name=preemptible" json:"preemptible,omitempty"`
	// OPTIONAL
	//
	// Requested RAM required in gigabytes (GB)
	RamGb float64 `protobuf:"fixed64,3,opt,name=ram_gb,json=ramGb" json:"ram_gb,omitempty"`
	// OPTIONAL
	//
	// Requested disk size in gigabytes (GB)
	DiskGb float64 `protobuf:"fixed64,4,opt,name=disk_gb,json=diskGb" json:"disk_gb,omitempty"`
	// OPTIONAL
	//
	// Request that the task be run in these compute zones.
	Zones []string `protobuf:"bytes,5,rep,name=zones" json:"zones,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Resources) GetCpuCores() uint32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *Resources) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *Resources) GetRamGb() float64 {
	if m != nil {
		return m.RamGb
	}
	return 0
}

func (m *Resources) GetDiskGb() float64 {
	if m != nil {
		return m.DiskGb
	}
	return 0
}

func (m *Resources) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

// OUTPUT ONLY
//
// TaskLog describes logging information related to a Task.
type TaskLog struct {
	// REQUIRED
	//
	// Logs for each executor
	Logs []*ExecutorLog `protobuf:"bytes,1,rep,name=logs" json:"logs,omitempty"`
	// OPTIONAL
	//
	// Arbitrary logging metadata included by the implementation.
	Metadata map[string]string `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// OPTIONAL
	//
	// When the task started, in RFC 3339 format.
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// OPTIONAL
	//
	// When the task ended, in RFC 3339 format.
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// REQUIRED
	//
	// Information about all output files. Directory outputs are
	// flattened into separate items.
	Outputs []*OutputFileLog `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	// OPTIONAL
	//
	// System logs are any logs the system decides are relevant,
	// which are not tied directly to an Executor process.
	// Content is implementation specific: format, size, etc.
	//
	// System logs may be collected here to provide convenient access.
	//
	// For example, the system may include the name of the host
	// where the task is executing, an error message that caused
	// a SYSTEM_ERROR state (e.g. disk is full), etc.
	//
	// System logs are only included in the FULL task view.
	SystemLogs []string `protobuf:"bytes,6,rep,name=system_logs,json=systemLogs" json:"system_logs,omitempty"`
}

func (m *TaskLog) Reset()                    { *m = TaskLog{} }
func (m *TaskLog) String() string            { return proto.CompactTextString(m) }
func (*TaskLog) ProtoMessage()               {}
func (*TaskLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TaskLog) GetLogs() []*ExecutorLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *TaskLog) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *TaskLog) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *TaskLog) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *TaskLog) GetOutputs() []*OutputFileLog {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *TaskLog) GetSystemLogs() []string {
	if m != nil {
		return m.SystemLogs
	}
	return nil
}

// OUTPUT ONLY
//
// ExecutorLog describes logging information related to an Executor.
type ExecutorLog struct {
	// OPTIONAL
	//
	// Time the executor started, in RFC 3339 format.
	StartTime string `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// OPTIONAL
	//
	// Time the executor ended, in RFC 3339 format.
	EndTime string `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// OPTIONAL
	//
	// Stdout content.
	//
	// This is meant for convenience. No guarantees are made about the content.
	// Implementations may chose different approaches: only the head, only the tail,
	// a URL reference only, etc.
	//
	// In order to capture the full stdout users should set Executor.stdout
	// to a container file path, and use Task.outputs to upload that file
	// to permanent storage.
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// OPTIONAL
	//
	// Stderr content.
	//
	// This is meant for convenience. No guarantees are made about the content.
	// Implementations may chose different approaches: only the head, only the tail,
	// a URL reference only, etc.
	//
	// In order to capture the full stderr users should set Executor.stderr
	// to a container file path, and use Task.outputs to upload that file
	// to permanent storage.
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
	// REQUIRED
	//
	// Exit code.
	ExitCode int32 `protobuf:"varint,6,opt,name=exit_code,json=exitCode" json:"exit_code,omitempty"`
}

func (m *ExecutorLog) Reset()                    { *m = ExecutorLog{} }
func (m *ExecutorLog) String() string            { return proto.CompactTextString(m) }
func (*ExecutorLog) ProtoMessage()               {}
func (*ExecutorLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ExecutorLog) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *ExecutorLog) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *ExecutorLog) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *ExecutorLog) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *ExecutorLog) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

// OUTPUT ONLY
//
// OutputFileLog describes a single output file. This describes
// file details after the task has completed successfully,
// for logging purposes.
type OutputFileLog struct {
	// REQUIRED
	//
	// URL of the file in storage, e.g. s3://bucket/file.txt
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// REQUIRED
	//
	// Path of the file inside the container. Must be an absolute path.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	//
	// Size of the file in bytes.
	SizeBytes int64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
}

func (m *OutputFileLog) Reset()                    { *m = OutputFileLog{} }
func (m *OutputFileLog) String() string            { return proto.CompactTextString(m) }
func (*OutputFileLog) ProtoMessage()               {}
func (*OutputFileLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *OutputFileLog) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *OutputFileLog) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OutputFileLog) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// OUTPUT ONLY
//
// CreateTaskResponse describes a response from the CreateTask endpoint.
type CreateTaskResponse struct {
	// REQUIRED
	//
	// Task identifier assigned by the server.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *CreateTaskResponse) Reset()                    { *m = CreateTaskResponse{} }
func (m *CreateTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateTaskResponse) ProtoMessage()               {}
func (*CreateTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateTaskResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// GetTaskRequest describes a request to the GetTask endpoint.
type GetTaskRequest struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// OPTIONAL
	//
	// Affects the fields included in the returned Task messages.
	// See TaskView below.
	View TaskView `protobuf:"varint,2,opt,name=view,enum=tes.TaskView" json:"view,omitempty"`
}

func (m *GetTaskRequest) Reset()                    { *m = GetTaskRequest{} }
func (m *GetTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTaskRequest) ProtoMessage()               {}
func (*GetTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetTaskRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetTaskRequest) GetView() TaskView {
	if m != nil {
		return m.View
	}
	return TaskView_MINIMAL
}

// ListTasksRequest describes a request to the ListTasks service endpoint.
type ListTasksRequest struct {
	// OPTIONAL
	//
	// Number of tasks to return in one page.
	// Must be less than 2048. Defaults to 256.
	PageSize uint32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// OPTIONAL
	//
	// Page token is used to retrieve the next page of results.
	// If unspecified, returns the first page of results.
	// See ListTasksResponse.next_page_token
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// OPTIONAL
	//
	// Affects the fields included in the returned Task messages.
	// See TaskView below.
	View TaskView `protobuf:"varint,5,opt,name=view,enum=tes.TaskView" json:"view,omitempty"`
	// OPTIONAL
	//
	// Filter tasks by state.
	// Filtering by the UNKNOWN state is not allowed.
	State State `protobuf:"varint,6,opt,name=state,enum=tes.State" json:"state,omitempty"`
	// OPTIONAL
	//
	// Filter tasks based on the Task.tags field.
	// A tag filter matches a Task tag if both the key and value are exact matches.
	//
	//   Filter                            Tags                          Match?
	//   ----------------------------------------------------------------------
	//   {"foo": "bar"}                    {"foo": "bar"}                Yes
	//   {"foo": ""}                       {"foo": ""}                   Yes
	//   {"foo": "bar", "baz": "bat"}      {"foo": "bar", "baz": "bat"}  Yes
	//   {"foo": "bar"}                    {"foo": "bar", "baz": "bat"}  Yes
	//   {"foo": "bar", "baz": "bat"}      {"foo": "bar"}                No
	//   {"foo": ""}                       {"foo": "bar"}                No
	Tags map[string]string `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListTasksRequest) Reset()                    { *m = ListTasksRequest{} }
func (m *ListTasksRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTasksRequest) ProtoMessage()               {}
func (*ListTasksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListTasksRequest) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListTasksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListTasksRequest) GetView() TaskView {
	if m != nil {
		return m.View
	}
	return TaskView_MINIMAL
}

func (m *ListTasksRequest) GetState() State {
	if m != nil {
		return m.State
	}
	return State_UNKNOWN
}

func (m *ListTasksRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// OUTPUT ONLY
//
// ListTasksResponse describes a response from the ListTasks endpoint.
type ListTasksResponse struct {
	// REQUIRED
	//
	// List of tasks.
	Tasks []*Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
	// OPTIONAL
	//
	// Token used to return the next page of results.
	// See TaskListRequest.next_page_token
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListTasksResponse) Reset()                    { *m = ListTasksResponse{} }
func (m *ListTasksResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTasksResponse) ProtoMessage()               {}
func (*ListTasksResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListTasksResponse) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ListTasksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// CancelTaskRequest describes a request to the CancelTask endpoint.
type CancelTaskRequest struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *CancelTaskRequest) Reset()                    { *m = CancelTaskRequest{} }
func (m *CancelTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelTaskRequest) ProtoMessage()               {}
func (*CancelTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CancelTaskRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// OUTPUT ONLY
//
// CancelTaskResponse describes a response from the CancelTask endpoint.
type CancelTaskResponse struct {
}

func (m *CancelTaskResponse) Reset()                    { *m = CancelTaskResponse{} }
func (m *CancelTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*CancelTaskResponse) ProtoMessage()               {}
func (*CancelTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// ServiceInfoRequest describes a request to the ServiceInfo endpoint.
type ServiceInfoRequest struct {
}

func (m *ServiceInfoRequest) Reset()                    { *m = ServiceInfoRequest{} }
func (m *ServiceInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfoRequest) ProtoMessage()               {}
func (*ServiceInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// OUTPUT ONLY
//
// ServiceInfo describes information about the service,
// such as storage details, resource availability,
// and other documentation.
type ServiceInfo struct {
	// Returns the name of the service, e.g. "ohsu-compbio-funnel".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Returns a documentation string, e.g. "Hey, we're OHSU Comp. Bio!".
	Doc string `protobuf:"bytes,2,opt,name=doc" json:"doc,omitempty"`
	// Lists some, but not necessarily all, storage locations supported by the service.
	//
	// Must be in a valid URL format.
	// e.g.
	// file:///path/to/local/funnel-storage
	// s3://ohsu-compbio-funnel/storage
	// etc.
	Storage         []string         `protobuf:"bytes,3,rep,name=storage" json:"storage,omitempty"`
	TaskStateCounts map[string]int32 `protobuf:"bytes,4,rep,name=task_state_counts,json=taskStateCounts" json:"task_state_counts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *ServiceInfo) Reset()                    { *m = ServiceInfo{} }
func (m *ServiceInfo) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfo) ProtoMessage()               {}
func (*ServiceInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ServiceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceInfo) GetDoc() string {
	if m != nil {
		return m.Doc
	}
	return ""
}

func (m *ServiceInfo) GetStorage() []string {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *ServiceInfo) GetTaskStateCounts() map[string]int32 {
	if m != nil {
		return m.TaskStateCounts
	}
	return nil
}

func init() {
	proto.RegisterType((*Task)(nil), "tes.Task")
	proto.RegisterType((*Input)(nil), "tes.Input")
	proto.RegisterType((*Output)(nil), "tes.Output")
	proto.RegisterType((*Executor)(nil), "tes.Executor")
	proto.RegisterType((*Resources)(nil), "tes.Resources")
	proto.RegisterType((*TaskLog)(nil), "tes.TaskLog")
	proto.RegisterType((*ExecutorLog)(nil), "tes.ExecutorLog")
	proto.RegisterType((*OutputFileLog)(nil), "tes.OutputFileLog")
	proto.RegisterType((*CreateTaskResponse)(nil), "tes.CreateTaskResponse")
	proto.RegisterType((*GetTaskRequest)(nil), "tes.GetTaskRequest")
	proto.RegisterType((*ListTasksRequest)(nil), "tes.ListTasksRequest")
	proto.RegisterType((*ListTasksResponse)(nil), "tes.ListTasksResponse")
	proto.RegisterType((*CancelTaskRequest)(nil), "tes.CancelTaskRequest")
	proto.RegisterType((*CancelTaskResponse)(nil), "tes.CancelTaskResponse")
	proto.RegisterType((*ServiceInfoRequest)(nil), "tes.ServiceInfoRequest")
	proto.RegisterType((*ServiceInfo)(nil), "tes.ServiceInfo")
	proto.RegisterEnum("tes.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("tes.State", State_name, State_value)
	proto.RegisterEnum("tes.TaskView", TaskView_name, TaskView_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TaskService service

type TaskServiceClient interface {
	// GetServiceInfo provides information about the service,
	// such as storage details, resource availability, and
	// other documentation.
	GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error)
	// Create a new task.
	CreateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*CreateTaskResponse, error)
	// List tasks.
	// TaskView is requested as such: "v1/tasks?view=BASIC"
	// Filter examples:
	// "v1/tasks?view=MINIMAL&tags[workflowID]=e59fb57a-eb87-4c02-b7e2-562b586b5db3"
	// "v1/tasks?state=RUNNING"
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	// Get a task.
	// TaskView is requested as such: "v1/tasks/{id}?view=FULL"
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error)
	// Cancel a task.
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error)
}

type taskServiceClient struct {
	cc *grpc.ClientConn
}

func NewTaskServiceClient(cc *grpc.ClientConn) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error) {
	out := new(ServiceInfo)
	err := grpc.Invoke(ctx, "/tes.TaskService/GetServiceInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) CreateTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*CreateTaskResponse, error) {
	out := new(CreateTaskResponse)
	err := grpc.Invoke(ctx, "/tes.TaskService/CreateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	out := new(ListTasksResponse)
	err := grpc.Invoke(ctx, "/tes.TaskService/ListTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/tes.TaskService/GetTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error) {
	out := new(CancelTaskResponse)
	err := grpc.Invoke(ctx, "/tes.TaskService/CancelTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TaskService service

type TaskServiceServer interface {
	// GetServiceInfo provides information about the service,
	// such as storage details, resource availability, and
	// other documentation.
	GetServiceInfo(context.Context, *ServiceInfoRequest) (*ServiceInfo, error)
	// Create a new task.
	CreateTask(context.Context, *Task) (*CreateTaskResponse, error)
	// List tasks.
	// TaskView is requested as such: "v1/tasks?view=BASIC"
	// Filter examples:
	// "v1/tasks?view=MINIMAL&tags[workflowID]=e59fb57a-eb87-4c02-b7e2-562b586b5db3"
	// "v1/tasks?state=RUNNING"
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	// Get a task.
	// TaskView is requested as such: "v1/tasks/{id}?view=FULL"
	GetTask(context.Context, *GetTaskRequest) (*Task, error)
	// Cancel a task.
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskResponse, error)
}

func RegisterTaskServiceServer(s *grpc.Server, srv TaskServiceServer) {
	s.RegisterService(&_TaskService_serviceDesc, srv)
}

func _TaskService_GetServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/GetServiceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, req.(*ServiceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/CreateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CreateTask(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/ListTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/GetTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/CancelTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TaskService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tes.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServiceInfo",
			Handler:    _TaskService_GetServiceInfo_Handler,
		},
		{
			MethodName: "CreateTask",
			Handler:    _TaskService_CreateTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _TaskService_ListTasks_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _TaskService_GetTask_Handler,
		},
		{
			MethodName: "CancelTask",
			Handler:    _TaskService_CancelTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tes.proto",
}

func init() { proto.RegisterFile("tes.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1382 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xdf, 0x6e, 0x1b, 0x45,
	0x17, 0xef, 0xda, 0x5e, 0x7b, 0xf7, 0x38, 0x76, 0x37, 0xf3, 0xa5, 0xe9, 0x7e, 0xee, 0xd7, 0xaf,
	0xee, 0xb6, 0x85, 0x28, 0x94, 0x44, 0xa4, 0x52, 0x41, 0xe5, 0x2a, 0x75, 0xb6, 0x91, 0x85, 0xe3,
	0xb4, 0x13, 0x07, 0x28, 0x54, 0xb2, 0x36, 0xbb, 0x83, 0x59, 0xc5, 0xde, 0x35, 0x3b, 0xe3, 0xb4,
	0x29, 0xe2, 0x02, 0x6e, 0xb8, 0x42, 0x42, 0x82, 0x07, 0x40, 0xdc, 0xf3, 0x34, 0x5c, 0xf0, 0x02,
	0x7d, 0x0c, 0x2e, 0xd0, 0x9c, 0x99, 0xf5, 0x9f, 0xa4, 0x2d, 0x2a, 0x37, 0xdc, 0xed, 0xf9, 0x9d,
	0x33, 0xbf, 0x39, 0xff, 0xc7, 0x06, 0x5b, 0x30, 0xbe, 0x31, 0xce, 0x52, 0x91, 0x92, 0xa2, 0x60,
	0xbc, 0xf1, 0xbf, 0x41, 0x9a, 0x0e, 0x86, 0x6c, 0x33, 0x18, 0xc7, 0x9b, 0x41, 0x92, 0xa4, 0x22,
	0x10, 0x71, 0x9a, 0x68, 0x13, 0xef, 0x8f, 0x22, 0x94, 0x7a, 0x01, 0x3f, 0x26, 0x75, 0x28, 0xc4,
	0x91, 0x6b, 0x34, 0x8d, 0x35, 0x9b, 0x16, 0xe2, 0x88, 0x34, 0xc1, 0xe4, 0x22, 0x10, 0xcc, 0x2d,
	0x34, 0x8d, 0xb5, 0xfa, 0x16, 0x6c, 0x48, 0xda, 0x03, 0x89, 0x50, 0xa5, 0x20, 0x04, 0x4a, 0x49,
	0x30, 0x62, 0x6e, 0x11, 0xcf, 0xe0, 0x37, 0x69, 0x42, 0x35, 0x62, 0x3c, 0xcc, 0xe2, 0xb1, 0xbc,
	0xc4, 0x35, 0x51, 0x35, 0x0f, 0x11, 0x0f, 0xca, 0x71, 0x32, 0x9e, 0x08, 0xee, 0x96, 0x9b, 0xc5,
	0xb5, 0xaa, 0x26, 0x6e, 0x4b, 0x88, 0x6a, 0x0d, 0xb9, 0x05, 0x95, 0x74, 0x22, 0xd0, 0xa8, 0x82,
	0x46, 0x55, 0x34, 0xda, 0x47, 0x8c, 0xe6, 0x3a, 0x72, 0x1b, 0xec, 0x8c, 0xf1, 0x74, 0x92, 0x85,
	0x8c, 0xbb, 0x56, 0xd3, 0x58, 0xab, 0x6e, 0xd5, 0xd1, 0x90, 0xe6, 0x28, 0x9d, 0x19, 0x90, 0x77,
	0xc0, 0x66, 0xcf, 0x58, 0x38, 0x11, 0x69, 0xc6, 0x5d, 0x1b, 0x69, 0x6b, 0x68, 0xed, 0x6b, 0x94,
	0xce, 0xf4, 0xc4, 0x85, 0xca, 0x49, 0x3a, 0x9c, 0x8c, 0x18, 0x77, 0xa1, 0x59, 0x5c, 0xb3, 0x69,
	0x2e, 0x92, 0xb7, 0xa1, 0x24, 0x82, 0x01, 0x77, 0xab, 0xc8, 0xf0, 0x1f, 0x64, 0x90, 0x09, 0xdc,
	0xe8, 0x05, 0x03, 0xee, 0x27, 0x22, 0x3b, 0xa5, 0x68, 0x40, 0x9a, 0x50, 0x1a, 0xa6, 0x03, 0xee,
	0x2e, 0xa1, 0xe1, 0xd2, 0xd4, 0xb0, 0x93, 0x0e, 0x28, 0x6a, 0xc8, 0x0d, 0xa8, 0x85, 0x19, 0xc3,
	0x72, 0xf4, 0x45, 0x3c, 0x62, 0x6e, 0x0d, 0xd3, 0xb5, 0x94, 0x83, 0xbd, 0x78, 0xc4, 0x1a, 0xef,
	0x83, 0x3d, 0x65, 0x26, 0x0e, 0x14, 0x8f, 0xd9, 0xa9, 0xae, 0x92, 0xfc, 0x24, 0x2b, 0x60, 0x9e,
	0x04, 0xc3, 0x89, 0x2a, 0x93, 0x4d, 0x95, 0x70, 0xaf, 0xf0, 0x81, 0xe1, 0xfd, 0x62, 0x80, 0x89,
	0x69, 0x9d, 0x16, 0xca, 0x78, 0x75, 0xa1, 0x0a, 0xe7, 0x0b, 0xe5, 0x40, 0x71, 0x92, 0x0d, 0x75,
	0x75, 0xe5, 0xa7, 0xe4, 0x19, 0x07, 0xe2, 0x4b, 0xb7, 0xa4, 0x78, 0xe4, 0x37, 0xb9, 0x0e, 0x25,
	0x71, 0x3a, 0x66, 0x58, 0xe9, 0xba, 0x4e, 0xe8, 0x83, 0x78, 0xc8, 0x7a, 0xa7, 0x63, 0x46, 0x51,
	0x25, 0x73, 0x19, 0xa6, 0x89, 0x60, 0x89, 0x70, 0xcb, 0x78, 0x32, 0x17, 0xbd, 0xef, 0x0d, 0x28,
	0xab, 0xa2, 0xfe, 0xcb, 0x3e, 0x7a, 0x7f, 0x1a, 0x60, 0xe5, 0x7d, 0x20, 0x73, 0x1a, 0x8f, 0x82,
	0x41, 0xee, 0x8c, 0x12, 0x54, 0x18, 0xa3, 0x51, 0x90, 0x44, 0x6e, 0x41, 0xb5, 0x84, 0x16, 0xa5,
	0xe6, 0x69, 0x9a, 0x1d, 0x47, 0x71, 0xa6, 0x3d, 0xc9, 0x45, 0xc9, 0xc4, 0x45, 0x14, 0x27, 0x3a,
	0x70, 0x25, 0x90, 0x55, 0x28, 0x73, 0x11, 0xa5, 0x13, 0xa1, 0xbd, 0xd4, 0x92, 0xc6, 0x59, 0x96,
	0xe9, 0xb9, 0xd1, 0x12, 0x59, 0x83, 0x22, 0x4b, 0x4e, 0x5c, 0x0b, 0x1b, 0x69, 0x75, 0xa1, 0x67,
	0x37, 0xfc, 0xe4, 0x44, 0x35, 0x9d, 0x34, 0x69, 0xdc, 0x05, 0x2b, 0x07, 0xde, 0xa8, 0x57, 0x7e,
	0x34, 0xc0, 0x9e, 0x0e, 0x0d, 0xb9, 0x02, 0x76, 0x38, 0x9e, 0xf4, 0xc3, 0x34, 0x63, 0x1c, 0xcf,
	0xd7, 0xa8, 0x15, 0x8e, 0x27, 0x2d, 0x29, 0xcb, 0xa2, 0x8c, 0x33, 0xc6, 0x46, 0x63, 0x11, 0x1f,
	0x0d, 0x15, 0x95, 0x45, 0xe7, 0x21, 0x72, 0x09, 0xca, 0x59, 0x30, 0xea, 0x0f, 0x8e, 0x30, 0x1b,
	0x06, 0x35, 0xb3, 0x60, 0xb4, 0x7b, 0x44, 0x2e, 0x43, 0x25, 0x8a, 0xf9, 0xb1, 0xc4, 0x4b, 0x88,
	0x97, 0xa5, 0xb8, 0x7b, 0x24, 0xdd, 0x7a, 0x9e, 0x26, 0x8c, 0xbb, 0x26, 0xa6, 0x55, 0x09, 0xde,
	0x6f, 0x05, 0xa8, 0xe8, 0x71, 0x21, 0x37, 0xf5, 0x28, 0x19, 0x98, 0x01, 0x67, 0x21, 0x03, 0xb3,
	0x71, 0xba, 0x0b, 0xd6, 0x88, 0x89, 0x20, 0x0a, 0x44, 0x80, 0x15, 0xaa, 0x6e, 0x35, 0xe6, 0x87,
	0x6e, 0x63, 0x4f, 0x2b, 0x55, 0xbe, 0xa6, 0xb6, 0xe4, 0x2a, 0x00, 0x17, 0x41, 0x26, 0xd4, 0x0c,
	0xaa, 0x0a, 0xda, 0x88, 0xc8, 0x01, 0x24, 0xff, 0x05, 0x8b, 0x25, 0x91, 0x52, 0xaa, 0x7a, 0x55,
	0x58, 0x12, 0xa1, 0xea, 0xf6, 0x6c, 0x4f, 0x99, 0x78, 0x21, 0x99, 0xdb, 0x53, 0xb2, 0xc3, 0xa4,
	0x73, 0xd3, 0x75, 0x75, 0x0d, 0xaa, 0xfc, 0x94, 0x0b, 0x36, 0xea, 0x63, 0x30, 0x65, 0x8c, 0x16,
	0x14, 0xd4, 0x49, 0x07, 0xbc, 0xf1, 0x21, 0xd4, 0x16, 0x7c, 0x7c, 0xa3, 0x12, 0xfe, 0x6c, 0x40,
	0x75, 0x2e, 0x27, 0x67, 0xa2, 0x2a, 0xbc, 0x2e, 0xaa, 0xe2, 0x62, 0x54, 0x6f, 0xda, 0x9e, 0x57,
	0xe4, 0x62, 0x8d, 0x45, 0x3f, 0x4c, 0x23, 0x86, 0x8d, 0x6e, 0x52, 0x4b, 0x02, 0xad, 0x34, 0x62,
	0x5e, 0x0f, 0x6a, 0x0b, 0xe9, 0xc8, 0x47, 0xd6, 0x38, 0x3f, 0xb2, 0x85, 0xb9, 0x91, 0x95, 0xde,
	0xc7, 0xcf, 0x59, 0xff, 0xe8, 0x54, 0x30, 0x8e, 0x0e, 0x16, 0xa9, 0x2d, 0x91, 0xfb, 0x12, 0xf0,
	0x6e, 0x02, 0x69, 0xc9, 0x25, 0xc9, 0x64, 0x6d, 0x29, 0xe3, 0xe3, 0x34, 0xe1, 0xec, 0xec, 0x13,
	0xe6, 0xb5, 0xa0, 0xbe, 0xcb, 0x84, 0x32, 0xf9, 0x6a, 0xc2, 0xb8, 0x38, 0xf7, 0xc8, 0x5d, 0x87,
	0xd2, 0x49, 0xcc, 0x9e, 0xea, 0x37, 0xae, 0x36, 0x6d, 0x97, 0x8f, 0x63, 0xf6, 0x94, 0xa2, 0xca,
	0xfb, 0xb6, 0x00, 0x4e, 0x27, 0xe6, 0x48, 0xc3, 0x73, 0x9e, 0x2b, 0x60, 0x8f, 0x83, 0x01, 0xeb,
	0x4b, 0x8f, 0xd0, 0xbb, 0x1a, 0xb5, 0x24, 0x70, 0x10, 0x3f, 0x67, 0xd2, 0x77, 0x54, 0x8a, 0xf4,
	0x98, 0x25, 0x3a, 0x87, 0x68, 0xde, 0x93, 0xc0, 0xf4, 0x4e, 0xf3, 0x95, 0x77, 0xce, 0xde, 0xde,
	0xf2, 0xab, 0xde, 0xde, 0x3b, 0xfa, 0x15, 0x52, 0xcf, 0xe3, 0x35, 0x34, 0x38, 0xeb, 0xe5, 0xd9,
	0x17, 0xe9, 0x9f, 0x3f, 0x25, 0x4f, 0x60, 0x79, 0x8e, 0x5c, 0x67, 0xfb, 0x1a, 0x98, 0x42, 0x02,
	0x7a, 0x2a, 0xed, 0x69, 0x20, 0x54, 0xe1, 0xe4, 0x2d, 0xb8, 0x98, 0xb0, 0x67, 0xa2, 0x3f, 0x97,
	0x0c, 0xc5, 0x5c, 0x93, 0xf0, 0xc3, 0x3c, 0x21, 0xde, 0x0d, 0x58, 0x6e, 0x05, 0x49, 0xc8, 0x86,
	0xaf, 0xa9, 0x94, 0xb7, 0x02, 0x64, 0xde, 0x48, 0xf9, 0x20, 0xd1, 0x03, 0x96, 0x9d, 0xc4, 0x21,
	0x6b, 0x27, 0x5f, 0xa4, 0xfa, 0xac, 0xf7, 0xc2, 0x80, 0xea, 0x1c, 0xfc, 0xd2, 0xb7, 0xc5, 0x81,
	0x62, 0x94, 0x86, 0xda, 0x21, 0xf9, 0x29, 0xb7, 0x38, 0x17, 0x69, 0x26, 0xf7, 0x7e, 0x51, 0xed,
	0x77, 0x2d, 0x92, 0x47, 0xb0, 0x2c, 0x23, 0xea, 0x63, 0xea, 0xfb, 0x61, 0x3a, 0x49, 0x04, 0x77,
	0x4b, 0x18, 0xf5, 0x2d, 0x55, 0x9a, 0xd9, 0x65, 0x98, 0x01, 0x2c, 0x55, 0x0b, 0xed, 0x54, 0xfe,
	0x2f, 0x8a, 0x45, 0xb4, 0x71, 0x1f, 0x56, 0x5e, 0x66, 0xf8, 0x77, 0x55, 0x31, 0xe7, 0xaa, 0xb2,
	0x7e, 0x03, 0xac, 0xfc, 0x15, 0x23, 0x16, 0x94, 0x1e, 0xb4, 0x3b, 0xbe, 0x73, 0x81, 0xd4, 0xc0,
	0xde, 0x69, 0x53, 0xbf, 0xd5, 0xdb, 0xa7, 0x8f, 0x1d, 0x63, 0xfd, 0x07, 0x03, 0x4c, 0xbc, 0x85,
	0x54, 0xa1, 0x72, 0xd8, 0xfd, 0xa8, 0xbb, 0xff, 0x49, 0xd7, 0xb9, 0x40, 0x00, 0xca, 0x8f, 0x0e,
	0xfd, 0x43, 0x7f, 0xc7, 0x31, 0x88, 0x03, 0x4b, 0xed, 0x6e, 0xbb, 0xd7, 0xde, 0xee, 0xb4, 0x3f,
	0x6b, 0x77, 0x77, 0x9d, 0x82, 0x34, 0xa5, 0x87, 0xdd, 0xae, 0x14, 0x8a, 0xd2, 0xf4, 0xe1, 0xf6,
	0xe1, 0x81, 0xbf, 0xe3, 0x94, 0xc8, 0x12, 0x58, 0xad, 0xfd, 0xbd, 0x87, 0x1d, 0xbf, 0xe7, 0x3b,
	0x26, 0x21, 0x50, 0xf7, 0x3f, 0xf5, 0x5b, 0x87, 0xbd, 0x7d, 0xda, 0xf7, 0x29, 0xdd, 0xa7, 0x4e,
	0x59, 0x92, 0x1d, 0x3c, 0x3e, 0xe8, 0xf9, 0x7b, 0x1a, 0xa9, 0xe0, 0x99, 0xed, 0x6e, 0xcb, 0xef,
	0xf8, 0x3b, 0x8e, 0xb5, 0x7e, 0x1b, 0xac, 0xbc, 0xd9, 0xe5, 0x35, 0x7b, 0xed, 0x6e, 0x7b, 0x6f,
	0xbb, 0xe3, 0x5c, 0x20, 0x36, 0x98, 0xf7, 0xb7, 0x0f, 0xda, 0x2d, 0xc7, 0xc0, 0x60, 0x0e, 0x3b,
	0x1d, 0xa7, 0xb0, 0xf5, 0x6b, 0x11, 0xaa, 0x98, 0x27, 0x95, 0x60, 0xf2, 0x39, 0x4e, 0xf4, 0x7c,
	0x6d, 0x2f, 0x9f, 0x2d, 0x80, 0x6e, 0x82, 0x86, 0x73, 0x56, 0xe1, 0xfd, 0xff, 0xbb, 0xdf, 0x5f,
	0xfc, 0x54, 0x70, 0xc9, 0xea, 0xe6, 0xc9, 0x7b, 0x9b, 0xd8, 0xa2, 0x9b, 0x5c, 0xa9, 0xdf, 0x8d,
	0x25, 0xd5, 0x03, 0x80, 0xd9, 0x52, 0x21, 0xb3, 0x7e, 0x6e, 0xa8, 0x3b, 0xce, 0x2f, 0x1c, 0x6f,
	0x05, 0x19, 0xeb, 0x9e, 0x3d, 0x65, 0xbc, 0x67, 0xac, 0x93, 0x3d, 0xb0, 0xa7, 0xd3, 0x42, 0x2e,
	0xbd, 0x74, 0x34, 0x1b, 0xab, 0x67, 0x61, 0xcd, 0xb8, 0x8c, 0x8c, 0x55, 0x32, 0x63, 0x24, 0xdb,
	0x50, 0xd1, 0x5b, 0x8c, 0xa8, 0x5f, 0x9b, 0x8b, 0x3b, 0xad, 0x31, 0x73, 0xd4, 0x5b, 0xc5, 0xd3,
	0x0e, 0xa9, 0xcf, 0x22, 0xfc, 0x3a, 0x8e, 0xbe, 0x21, 0x4f, 0x00, 0x66, 0xc3, 0x43, 0xd4, 0xdd,
	0xe7, 0x46, 0x2e, 0x0f, 0xf3, 0xfc, 0x94, 0x5d, 0x45, 0xda, 0xcb, 0xde, 0xa5, 0x45, 0xda, 0x7b,
	0x21, 0x9a, 0x1e, 0x95, 0xf1, 0x9f, 0xc4, 0x9d, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf4, 0xca,
	0x2c, 0x8f, 0x79, 0x0c, 0x00, 0x00,
}
