/*
Task Execution Service

## Executive Summary The Task Execution Service (TES) API is a standardized schema and API for describing and executing batch execution tasks. A task defines a set of input files, a set of containers and commands to run, a set of output files and some other logging and metadata.  TES servers accept task documents and execute them asynchronously on available compute resources. A TES server could be built on top of a traditional HPC queuing system, such as Grid Engine, Slurm or cloud style compute systems such as AWS Batch or Kubernetes. ## Introduction This document describes the TES API and provides details on the specific endpoints, request formats, and responses. It is intended to provide key information for developers of TES-compatible services as well as clients that will call these TES services. Use cases include:    - Deploying existing workflow engines on new infrastructure. Workflow engines   such as CWL-Tes and Cromwell have extentions for using TES. This will allow   a system engineer to deploy them onto a new infrastructure using a job scheduling   system not previously supported by the engine.    - Developing a custom workflow management system. This API provides a common   interface to asynchronous batch processing capabilities. A developer can write   new tools against this interface and expect them to work using a variety of   backend solutions that all support the same specification.   ## Standards The TES API specification is written in OpenAPI and embodies a RESTful service philosophy. It uses JSON in requests and responses and standard HTTP/HTTPS for information transport. HTTPS should be used rather than plain HTTP except for testing or internal-only purposes. ### Authentication and Authorization Is is envisaged that most TES API instances will require users to authenticate to use the endpoints. However, the decision if authentication is required should be taken by TES API implementers.  If authentication is required, we recommend that TES implementations use an OAuth2  bearer token, although they can choose other mechanisms if appropriate.  Checking that a user is authorized to submit TES requests is a responsibility of TES implementations. ### CORS If TES API implementation is to be used by another website or domain it must implement Cross Origin Resource Sharing (CORS). Please refer to https://w3id.org/ga4gh/product-approval-support/cors for more information about GA4GHâ€™s recommendations and how to implement CORS. 

API version: 1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tes

import (
	"encoding/json"
	"fmt"
)

// TesState Task state as defined by the server.   - `UNKNOWN`: The state of the task is unknown. The cause for this status   message may be dependent on the underlying system. The `UNKNOWN` states   provides a safe default for messages where this field is missing so   that a missing field does not accidentally imply that   the state is QUEUED.  - `QUEUED`: The task is queued and awaiting resources to begin computing.  - `INITIALIZING`: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.  - `RUNNING`: The task is running. Input files are downloaded and the first Executor has been started.  - `PAUSED`: The task is paused. The reasons for this would be tied to   the specific system running the job. An implementation may have the ability   to pause a task, but this is not required.  - `COMPLETE`: The task has completed running. Executors have exited without error and output files have been successfully uploaded.  - `EXECUTOR_ERROR`: The task encountered an error in one of the Executor processes. Generally, this means that an Executor exited with a non-zero exit code.  - `SYSTEM_ERROR`: The task was stopped due to a system error, but not from an Executor, for example an upload failed due to network issues, the worker's ran out of disk space, etc.  - `CANCELED`: The task was canceled by the user, and downstream resources have been deleted.  - `CANCELING`: The task was canceled by the user, but the downstream resources are still awaiting deletion.  - `PREEMPTED`: The task is stopped (preempted) by the system. The reasons for this would be tied to the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation.
type TesState string

// List of tesState
const (
	UNKNOWN TesState = "UNKNOWN"
	QUEUED TesState = "QUEUED"
	INITIALIZING TesState = "INITIALIZING"
	RUNNING TesState = "RUNNING"
	PAUSED TesState = "PAUSED"
	COMPLETE TesState = "COMPLETE"
	EXECUTOR_ERROR TesState = "EXECUTOR_ERROR"
	SYSTEM_ERROR TesState = "SYSTEM_ERROR"
	CANCELED TesState = "CANCELED"
	PREEMPTED TesState = "PREEMPTED"
	CANCELING TesState = "CANCELING"
)

// All allowed values of TesState enum
var AllowedTesStateEnumValues = []TesState{
	"UNKNOWN",
	"QUEUED",
	"INITIALIZING",
	"RUNNING",
	"PAUSED",
	"COMPLETE",
	"EXECUTOR_ERROR",
	"SYSTEM_ERROR",
	"CANCELED",
	"PREEMPTED",
	"CANCELING",
}

func (v *TesState) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TesState(value)
	for _, existing := range AllowedTesStateEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TesState", value)
}

// NewTesStateFromValue returns a pointer to a valid TesState
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTesStateFromValue(v string) (*TesState, error) {
	ev := TesState(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TesState: valid values are %v", v, AllowedTesStateEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TesState) IsValid() bool {
	for _, existing := range AllowedTesStateEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to tesState value
func (v TesState) Ptr() *TesState {
	return &v
}

type NullableTesState struct {
	value *TesState
	isSet bool
}

func (v NullableTesState) Get() *TesState {
	return v.value
}

func (v *NullableTesState) Set(val *TesState) {
	v.value = val
	v.isSet = true
}

func (v NullableTesState) IsSet() bool {
	return v.isSet
}

func (v *NullableTesState) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTesState(val *TesState) *NullableTesState {
	return &NullableTesState{value: val, isSet: true}
}

func (v NullableTesState) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTesState) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

