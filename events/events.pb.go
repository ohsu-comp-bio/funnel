// Code generated by protoc-gen-go. DO NOT EDIT.
// source: events.proto

/*
Package events is a generated protocol buffer package.

It is generated from these files:
	events.proto

It has these top-level messages:
	Metadata
	Outputs
	Ports
	SystemLog
	Event
	CreateEventResponse
*/
package events

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import tes "github.com/ohsu-comp-bio/funnel/proto/tes"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_UNKNOWN             Type = 0
	Type_TASK_STATE          Type = 1
	Type_TASK_START_TIME     Type = 2
	Type_TASK_END_TIME       Type = 3
	Type_TASK_OUTPUTS        Type = 4
	Type_TASK_METADATA       Type = 5
	Type_EXECUTOR_START_TIME Type = 6
	Type_EXECUTOR_END_TIME   Type = 7
	Type_EXECUTOR_EXIT_CODE  Type = 8
	Type_EXECUTOR_HOST_IP    Type = 9
	Type_EXECUTOR_PORTS      Type = 10
	Type_EXECUTOR_STDOUT     Type = 11
	Type_EXECUTOR_STDERR     Type = 12
	Type_SYSTEM_LOG          Type = 13
	Type_TASK_CREATED        Type = 14
)

var Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TASK_STATE",
	2:  "TASK_START_TIME",
	3:  "TASK_END_TIME",
	4:  "TASK_OUTPUTS",
	5:  "TASK_METADATA",
	6:  "EXECUTOR_START_TIME",
	7:  "EXECUTOR_END_TIME",
	8:  "EXECUTOR_EXIT_CODE",
	9:  "EXECUTOR_HOST_IP",
	10: "EXECUTOR_PORTS",
	11: "EXECUTOR_STDOUT",
	12: "EXECUTOR_STDERR",
	13: "SYSTEM_LOG",
	14: "TASK_CREATED",
}
var Type_value = map[string]int32{
	"UNKNOWN":             0,
	"TASK_STATE":          1,
	"TASK_START_TIME":     2,
	"TASK_END_TIME":       3,
	"TASK_OUTPUTS":        4,
	"TASK_METADATA":       5,
	"EXECUTOR_START_TIME": 6,
	"EXECUTOR_END_TIME":   7,
	"EXECUTOR_EXIT_CODE":  8,
	"EXECUTOR_HOST_IP":    9,
	"EXECUTOR_PORTS":      10,
	"EXECUTOR_STDOUT":     11,
	"EXECUTOR_STDERR":     12,
	"SYSTEM_LOG":          13,
	"TASK_CREATED":        14,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Metadata struct {
	Value map[string]string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Metadata) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

type Outputs struct {
	Value []*tes.OutputFileLog `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *Outputs) Reset()                    { *m = Outputs{} }
func (m *Outputs) String() string            { return proto.CompactTextString(m) }
func (*Outputs) ProtoMessage()               {}
func (*Outputs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Outputs) GetValue() []*tes.OutputFileLog {
	if m != nil {
		return m.Value
	}
	return nil
}

type Ports struct {
	Value []*tes.Ports `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *Ports) Reset()                    { *m = Ports{} }
func (m *Ports) String() string            { return proto.CompactTextString(m) }
func (*Ports) ProtoMessage()               {}
func (*Ports) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Ports) GetValue() []*tes.Ports {
	if m != nil {
		return m.Value
	}
	return nil
}

type SystemLog struct {
	Msg    string            `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	Level  string            `protobuf:"bytes,2,opt,name=level" json:"level,omitempty"`
	Fields map[string]string `protobuf:"bytes,3,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SystemLog) Reset()                    { *m = SystemLog{} }
func (m *SystemLog) String() string            { return proto.CompactTextString(m) }
func (*SystemLog) ProtoMessage()               {}
func (*SystemLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SystemLog) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SystemLog) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SystemLog) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Event struct {
	Id        string                      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Timestamp *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Event_State
	//	*Event_StartTime
	//	*Event_EndTime
	//	*Event_Outputs
	//	*Event_Metadata
	//	*Event_ExitCode
	//	*Event_HostIp
	//	*Event_Ports
	//	*Event_Stdout
	//	*Event_Stderr
	//	*Event_SystemLog
	//	*Event_Task
	Data    isEvent_Data `protobuf_oneof:"data"`
	Attempt uint32       `protobuf:"varint,16,opt,name=attempt" json:"attempt,omitempty"`
	Index   uint32       `protobuf:"varint,17,opt,name=index" json:"index,omitempty"`
	Type    Type         `protobuf:"varint,18,opt,name=type,enum=events.Type" json:"type,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isEvent_Data interface {
	isEvent_Data()
}

type Event_State struct {
	State tes.State `protobuf:"varint,3,opt,name=state,enum=tes.State,oneof"`
}
type Event_StartTime struct {
	StartTime *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,oneof"`
}
type Event_EndTime struct {
	EndTime *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=end_time,json=endTime,oneof"`
}
type Event_Outputs struct {
	Outputs *Outputs `protobuf:"bytes,6,opt,name=outputs,oneof"`
}
type Event_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,7,opt,name=metadata,oneof"`
}
type Event_ExitCode struct {
	ExitCode int32 `protobuf:"varint,10,opt,name=exit_code,json=exitCode,oneof"`
}
type Event_HostIp struct {
	HostIp string `protobuf:"bytes,11,opt,name=host_ip,json=hostIp,oneof"`
}
type Event_Ports struct {
	Ports *Ports `protobuf:"bytes,12,opt,name=ports,oneof"`
}
type Event_Stdout struct {
	Stdout string `protobuf:"bytes,13,opt,name=stdout,oneof"`
}
type Event_Stderr struct {
	Stderr string `protobuf:"bytes,14,opt,name=stderr,oneof"`
}
type Event_SystemLog struct {
	SystemLog *SystemLog `protobuf:"bytes,15,opt,name=system_log,json=systemLog,oneof"`
}
type Event_Task struct {
	Task *tes.Task `protobuf:"bytes,19,opt,name=task,oneof"`
}

func (*Event_State) isEvent_Data()     {}
func (*Event_StartTime) isEvent_Data() {}
func (*Event_EndTime) isEvent_Data()   {}
func (*Event_Outputs) isEvent_Data()   {}
func (*Event_Metadata) isEvent_Data()  {}
func (*Event_ExitCode) isEvent_Data()  {}
func (*Event_HostIp) isEvent_Data()    {}
func (*Event_Ports) isEvent_Data()     {}
func (*Event_Stdout) isEvent_Data()    {}
func (*Event_Stderr) isEvent_Data()    {}
func (*Event_SystemLog) isEvent_Data() {}
func (*Event_Task) isEvent_Data()      {}

func (m *Event) GetData() isEvent_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Event) GetTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Event) GetState() tes.State {
	if x, ok := m.GetData().(*Event_State); ok {
		return x.State
	}
	return tes.State_UNKNOWN
}

func (m *Event) GetStartTime() *google_protobuf1.Timestamp {
	if x, ok := m.GetData().(*Event_StartTime); ok {
		return x.StartTime
	}
	return nil
}

func (m *Event) GetEndTime() *google_protobuf1.Timestamp {
	if x, ok := m.GetData().(*Event_EndTime); ok {
		return x.EndTime
	}
	return nil
}

func (m *Event) GetOutputs() *Outputs {
	if x, ok := m.GetData().(*Event_Outputs); ok {
		return x.Outputs
	}
	return nil
}

func (m *Event) GetMetadata() *Metadata {
	if x, ok := m.GetData().(*Event_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *Event) GetExitCode() int32 {
	if x, ok := m.GetData().(*Event_ExitCode); ok {
		return x.ExitCode
	}
	return 0
}

func (m *Event) GetHostIp() string {
	if x, ok := m.GetData().(*Event_HostIp); ok {
		return x.HostIp
	}
	return ""
}

func (m *Event) GetPorts() *Ports {
	if x, ok := m.GetData().(*Event_Ports); ok {
		return x.Ports
	}
	return nil
}

func (m *Event) GetStdout() string {
	if x, ok := m.GetData().(*Event_Stdout); ok {
		return x.Stdout
	}
	return ""
}

func (m *Event) GetStderr() string {
	if x, ok := m.GetData().(*Event_Stderr); ok {
		return x.Stderr
	}
	return ""
}

func (m *Event) GetSystemLog() *SystemLog {
	if x, ok := m.GetData().(*Event_SystemLog); ok {
		return x.SystemLog
	}
	return nil
}

func (m *Event) GetTask() *tes.Task {
	if x, ok := m.GetData().(*Event_Task); ok {
		return x.Task
	}
	return nil
}

func (m *Event) GetAttempt() uint32 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

func (m *Event) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Event) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_UNKNOWN
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Event_OneofMarshaler, _Event_OneofUnmarshaler, _Event_OneofSizer, []interface{}{
		(*Event_State)(nil),
		(*Event_StartTime)(nil),
		(*Event_EndTime)(nil),
		(*Event_Outputs)(nil),
		(*Event_Metadata)(nil),
		(*Event_ExitCode)(nil),
		(*Event_HostIp)(nil),
		(*Event_Ports)(nil),
		(*Event_Stdout)(nil),
		(*Event_Stderr)(nil),
		(*Event_SystemLog)(nil),
		(*Event_Task)(nil),
	}
}

func _Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Event)
	// data
	switch x := m.Data.(type) {
	case *Event_State:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.State))
	case *Event_StartTime:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StartTime); err != nil {
			return err
		}
	case *Event_EndTime:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndTime); err != nil {
			return err
		}
	case *Event_Outputs:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Outputs); err != nil {
			return err
		}
	case *Event_Metadata:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case *Event_ExitCode:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ExitCode))
	case *Event_HostIp:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.HostIp)
	case *Event_Ports:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ports); err != nil {
			return err
		}
	case *Event_Stdout:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Stdout)
	case *Event_Stderr:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Stderr)
	case *Event_SystemLog:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SystemLog); err != nil {
			return err
		}
	case *Event_Task:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Task); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Event.Data has unexpected type %T", x)
	}
	return nil
}

func _Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Event)
	switch tag {
	case 3: // data.state
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Event_State{tes.State(x)}
		return true, err
	case 4: // data.start_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Timestamp)
		err := b.DecodeMessage(msg)
		m.Data = &Event_StartTime{msg}
		return true, err
	case 5: // data.end_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Timestamp)
		err := b.DecodeMessage(msg)
		m.Data = &Event_EndTime{msg}
		return true, err
	case 6: // data.outputs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Outputs)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Outputs{msg}
		return true, err
	case 7: // data.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Metadata{msg}
		return true, err
	case 10: // data.exit_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Event_ExitCode{int32(x)}
		return true, err
	case 11: // data.host_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_HostIp{x}
		return true, err
	case 12: // data.ports
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Ports)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Ports{msg}
		return true, err
	case 13: // data.stdout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_Stdout{x}
		return true, err
	case 14: // data.stderr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_Stderr{x}
		return true, err
	case 15: // data.system_log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SystemLog)
		err := b.DecodeMessage(msg)
		m.Data = &Event_SystemLog{msg}
		return true, err
	case 19: // data.task
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(tes.Task)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Task{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Event)
	// data
	switch x := m.Data.(type) {
	case *Event_State:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.State))
	case *Event_StartTime:
		s := proto.Size(x.StartTime)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_EndTime:
		s := proto.Size(x.EndTime)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Outputs:
		s := proto.Size(x.Outputs)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_ExitCode:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ExitCode))
	case *Event_HostIp:
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HostIp)))
		n += len(x.HostIp)
	case *Event_Ports:
		s := proto.Size(x.Ports)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Stdout:
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Stdout)))
		n += len(x.Stdout)
	case *Event_Stderr:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Stderr)))
		n += len(x.Stderr)
	case *Event_SystemLog:
		s := proto.Size(x.SystemLog)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Task:
		s := proto.Size(x.Task)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CreateEventResponse struct {
}

func (m *CreateEventResponse) Reset()                    { *m = CreateEventResponse{} }
func (m *CreateEventResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateEventResponse) ProtoMessage()               {}
func (*CreateEventResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*Metadata)(nil), "events.Metadata")
	proto.RegisterType((*Outputs)(nil), "events.Outputs")
	proto.RegisterType((*Ports)(nil), "events.Ports")
	proto.RegisterType((*SystemLog)(nil), "events.SystemLog")
	proto.RegisterType((*Event)(nil), "events.Event")
	proto.RegisterType((*CreateEventResponse)(nil), "events.CreateEventResponse")
	proto.RegisterEnum("events.Type", Type_name, Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EventService service

type EventServiceClient interface {
	CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*CreateEventResponse, error)
}

type eventServiceClient struct {
	cc *grpc.ClientConn
}

func NewEventServiceClient(cc *grpc.ClientConn) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*CreateEventResponse, error) {
	out := new(CreateEventResponse)
	err := grpc.Invoke(ctx, "/events.EventService/CreateEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EventService service

type EventServiceServer interface {
	CreateEvent(context.Context, *Event) (*CreateEventResponse, error)
}

func RegisterEventServiceServer(s *grpc.Server, srv EventServiceServer) {
	s.RegisterService(&_EventService_serviceDesc, srv)
}

func _EventService_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventService/CreateEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "events.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEvent",
			Handler:    _EventService_CreateEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "events.proto",
}

func init() { proto.RegisterFile("events.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 801 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x5d, 0x6f, 0xe3, 0x44,
	0x14, 0x8d, 0x93, 0x38, 0x69, 0x6e, 0x3e, 0x3a, 0xbd, 0xdd, 0x85, 0x21, 0xb0, 0x22, 0x8a, 0x84,
	0x14, 0x40, 0xca, 0x8a, 0xae, 0x10, 0x05, 0x9e, 0x42, 0xe2, 0x25, 0x55, 0x3f, 0x5c, 0x8d, 0x27,
	0xb0, 0x3c, 0x59, 0xde, 0xf5, 0x6c, 0xb0, 0x9a, 0xd8, 0x96, 0x67, 0x52, 0x36, 0xff, 0x81, 0xbf,
	0xc1, 0x2b, 0xbf, 0x11, 0xcd, 0xf8, 0xa3, 0xd9, 0x82, 0x04, 0xbc, 0xe5, 0x9e, 0x73, 0xee, 0xbd,
	0x33, 0x67, 0x8e, 0x03, 0x3d, 0x71, 0x2f, 0x62, 0x25, 0xa7, 0x69, 0x96, 0xa8, 0x04, 0x5b, 0x79,
	0x35, 0xec, 0x28, 0x51, 0x40, 0xc3, 0x63, 0x15, 0x6d, 0x85, 0x54, 0xc1, 0x36, 0x2d, 0x80, 0x4f,
	0xd6, 0x49, 0xb2, 0xde, 0x88, 0xe7, 0x41, 0x1a, 0x3d, 0x0f, 0xe2, 0x38, 0x51, 0x81, 0x8a, 0x92,
	0xb8, 0x90, 0x8f, 0x7f, 0x83, 0xa3, 0x6b, 0xa1, 0x82, 0x30, 0x50, 0x01, 0x7e, 0x05, 0xf6, 0x7d,
	0xb0, 0xd9, 0x09, 0x6a, 0x8d, 0x1a, 0x93, 0xee, 0xd9, 0xc7, 0xd3, 0x62, 0x57, 0x29, 0x98, 0xfe,
	0xa4, 0x59, 0x27, 0x56, 0xd9, 0x9e, 0xe5, 0xca, 0xe1, 0x39, 0xc0, 0x03, 0x88, 0x04, 0x1a, 0x77,
	0x62, 0x4f, 0xad, 0x91, 0x35, 0xe9, 0x30, 0xfd, 0x13, 0x9f, 0x94, 0x23, 0xeb, 0x06, 0xcb, 0x8b,
	0xef, 0xea, 0xe7, 0xd6, 0xf8, 0x05, 0xb4, 0xdd, 0x9d, 0x4a, 0x77, 0x4a, 0xe2, 0xe4, 0xfd, 0xbd,
	0x38, 0xd5, 0xb7, 0xc9, 0xc9, 0x97, 0xd1, 0x46, 0x5c, 0x25, 0xeb, 0xa2, 0x71, 0xfc, 0x39, 0xd8,
	0xb7, 0x49, 0xa6, 0x24, 0x8e, 0xde, 0x6f, 0x01, 0xd3, 0x62, 0xa8, 0x52, 0xfa, 0x87, 0x05, 0x1d,
	0x6f, 0x2f, 0x95, 0xd8, 0x5e, 0x25, 0x6b, 0x7d, 0xb2, 0xad, 0x5c, 0x97, 0x27, 0xdb, 0xca, 0xb5,
	0x3e, 0xd9, 0x46, 0xdc, 0x8b, 0x4d, 0x79, 0x32, 0x53, 0xe0, 0xd7, 0xd0, 0x7a, 0x1b, 0x89, 0x4d,
	0x28, 0x69, 0xc3, 0x0c, 0x7e, 0x56, 0x7a, 0x50, 0x8d, 0x9a, 0xbe, 0x34, 0x7c, 0xee, 0x42, 0x21,
	0x1e, 0x7e, 0x0b, 0xdd, 0x03, 0xf8, 0x7f, 0xf9, 0xf0, 0xbb, 0x0d, 0xb6, 0xa3, 0x77, 0xe0, 0x00,
	0xea, 0x51, 0x58, 0x34, 0xd5, 0xa3, 0x10, 0xcf, 0xa1, 0x53, 0xbd, 0xa5, 0xe9, 0xeb, 0x9e, 0x0d,
	0xa7, 0xf9, 0x63, 0xe6, 0x8f, 0xf7, 0x7a, 0xf7, 0x76, 0xca, 0x4b, 0x05, 0x7b, 0x10, 0xe3, 0x18,
	0x6c, 0xa9, 0x02, 0x25, 0x68, 0x63, 0x64, 0x4d, 0x06, 0x85, 0x3b, 0x9e, 0x46, 0x96, 0x35, 0x96,
	0x53, 0xf8, 0x3d, 0x80, 0x54, 0x41, 0xa6, 0x7c, 0xdd, 0x46, 0x9b, 0xff, 0x36, 0x7e, 0x59, 0x63,
	0x1d, 0xa3, 0xd7, 0x08, 0x7e, 0x03, 0x47, 0x22, 0x0e, 0xf3, 0x56, 0xfb, 0x3f, 0xb4, 0xb6, 0x45,
	0x1c, 0x9a, 0xc6, 0x2f, 0xa1, 0x9d, 0xe4, 0xaf, 0x4e, 0x5b, 0xa6, 0xef, 0xb8, 0x34, 0xb8, 0x08,
	0x83, 0x16, 0x17, 0x0a, 0x9c, 0xc2, 0xd1, 0xb6, 0x88, 0x1e, 0x6d, 0x1b, 0x35, 0x79, 0x1c, 0xc9,
	0x65, 0x8d, 0x55, 0x1a, 0x7c, 0x06, 0x1d, 0xf1, 0x2e, 0x52, 0xfe, 0x9b, 0x24, 0x14, 0x14, 0x46,
	0xd6, 0xc4, 0xd6, 0xb4, 0x86, 0xe6, 0x49, 0x28, 0xf0, 0x23, 0x68, 0xff, 0x9a, 0x48, 0xe5, 0x47,
	0x29, 0xed, 0x6a, 0x93, 0x97, 0x35, 0xd6, 0xd2, 0xc0, 0x45, 0x8a, 0x9f, 0x81, 0x9d, 0xea, 0xf0,
	0xd0, 0x9e, 0x59, 0xd3, 0x2f, 0xd7, 0x98, 0x44, 0x69, 0xcf, 0x0c, 0x8b, 0x14, 0x5a, 0x52, 0x85,
	0xc9, 0x4e, 0xd1, 0x7e, 0x39, 0x20, 0xaf, 0x0b, 0x46, 0x64, 0x19, 0x1d, 0x1c, 0x30, 0x22, 0xcb,
	0xf0, 0x0c, 0x40, 0x9a, 0xec, 0xf8, 0x9b, 0x64, 0x4d, 0x8f, 0xcd, 0xfc, 0x93, 0xbf, 0xa5, 0xca,
	0xd8, 0x5b, 0xa5, 0xf5, 0x53, 0x68, 0xaa, 0x40, 0xde, 0xd1, 0x53, 0xa3, 0xee, 0x98, 0xe7, 0xe3,
	0x81, 0xbc, 0x5b, 0xd6, 0x98, 0x21, 0x90, 0x42, 0x3b, 0x50, 0x4a, 0x6c, 0x53, 0x45, 0xc9, 0xc8,
	0x9a, 0xf4, 0x59, 0x59, 0xea, 0xa0, 0x45, 0x71, 0x28, 0xde, 0xd1, 0x13, 0x83, 0xe7, 0x05, 0x8e,
	0xa0, 0xa9, 0xf6, 0xa9, 0xa0, 0x68, 0xf2, 0xd0, 0x2b, 0xd7, 0xf3, 0x7d, 0x2a, 0x98, 0x61, 0x7e,
	0x68, 0x41, 0x53, 0x7b, 0x38, 0x7e, 0x0a, 0xa7, 0xf3, 0x4c, 0x04, 0x4a, 0x98, 0x4c, 0x32, 0x21,
	0xd3, 0x24, 0x96, 0xe2, 0x8b, 0x3f, 0xeb, 0xd0, 0xd4, 0x6a, 0xec, 0x42, 0x7b, 0x75, 0x73, 0x79,
	0xe3, 0xfe, 0x7c, 0x43, 0x6a, 0x38, 0x00, 0xe0, 0x33, 0xef, 0xd2, 0xf7, 0xf8, 0x8c, 0x3b, 0xc4,
	0xc2, 0x53, 0x38, 0x2e, 0x6b, 0xc6, 0x7d, 0x7e, 0x71, 0xed, 0x90, 0x3a, 0x9e, 0x40, 0xdf, 0x80,
	0xce, 0xcd, 0x22, 0x87, 0x1a, 0x48, 0xa0, 0x67, 0x20, 0x77, 0xc5, 0x6f, 0x57, 0xdc, 0x23, 0xcd,
	0x4a, 0x74, 0xed, 0xf0, 0xd9, 0x62, 0xc6, 0x67, 0xc4, 0xc6, 0x0f, 0xe1, 0xd4, 0x79, 0xe5, 0xcc,
	0x57, 0xdc, 0x65, 0x87, 0x03, 0x5b, 0xf8, 0x14, 0x4e, 0x2a, 0xa2, 0x1a, 0xda, 0xc6, 0x0f, 0x00,
	0x1f, 0xe0, 0x57, 0x17, 0xdc, 0x9f, 0xbb, 0x0b, 0x87, 0x1c, 0xe1, 0x13, 0x20, 0x15, 0xbe, 0x74,
	0x3d, 0xee, 0x5f, 0xdc, 0x92, 0x0e, 0x22, 0x0c, 0x2a, 0xf4, 0xd6, 0x65, 0xdc, 0x23, 0xa0, 0x8f,
	0x7f, 0xb0, 0x71, 0xe1, 0xae, 0x38, 0xe9, 0x3e, 0x06, 0x1d, 0xc6, 0x48, 0x4f, 0x5f, 0xdc, 0xfb,
	0xc5, 0xe3, 0xce, 0xb5, 0x7f, 0xe5, 0xfe, 0x48, 0xfa, 0xd5, 0x85, 0xe6, 0xcc, 0x99, 0x71, 0x67,
	0x41, 0x06, 0x67, 0x97, 0xd0, 0x33, 0x0e, 0x7a, 0x22, 0xbb, 0x8f, 0xde, 0xe8, 0xcf, 0xad, 0x7b,
	0xe0, 0x2b, 0x56, 0x09, 0x33, 0xe5, 0xb0, 0xfa, 0xab, 0xfd, 0x07, 0xef, 0xc7, 0xb5, 0xd7, 0x2d,
	0xf3, 0x51, 0xbd, 0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xed, 0x64, 0x19, 0x6b, 0xfd, 0x05, 0x00,
	0x00,
}
