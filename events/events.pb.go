// Code generated by protoc-gen-go. DO NOT EDIT.
// source: events.proto

/*
Package events is a generated protocol buffer package.

It is generated from these files:
	events.proto

It has these top-level messages:
	Metadata
	Outputs
	SystemLog
	Event
	WriteEventResponse
*/
package events

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import tes "github.com/ohsu-comp-bio/funnel/tes"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_UNKNOWN             Type = 0
	Type_TASK_STATE          Type = 1
	Type_TASK_START_TIME     Type = 2
	Type_TASK_END_TIME       Type = 3
	Type_TASK_OUTPUTS        Type = 4
	Type_TASK_METADATA       Type = 5
	Type_EXECUTOR_START_TIME Type = 6
	Type_EXECUTOR_END_TIME   Type = 7
	Type_EXECUTOR_EXIT_CODE  Type = 8
	Type_EXECUTOR_STDOUT     Type = 11
	Type_EXECUTOR_STDERR     Type = 12
	Type_SYSTEM_LOG          Type = 13
	Type_TASK_CREATED        Type = 14
)

var Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TASK_STATE",
	2:  "TASK_START_TIME",
	3:  "TASK_END_TIME",
	4:  "TASK_OUTPUTS",
	5:  "TASK_METADATA",
	6:  "EXECUTOR_START_TIME",
	7:  "EXECUTOR_END_TIME",
	8:  "EXECUTOR_EXIT_CODE",
	11: "EXECUTOR_STDOUT",
	12: "EXECUTOR_STDERR",
	13: "SYSTEM_LOG",
	14: "TASK_CREATED",
}
var Type_value = map[string]int32{
	"UNKNOWN":             0,
	"TASK_STATE":          1,
	"TASK_START_TIME":     2,
	"TASK_END_TIME":       3,
	"TASK_OUTPUTS":        4,
	"TASK_METADATA":       5,
	"EXECUTOR_START_TIME": 6,
	"EXECUTOR_END_TIME":   7,
	"EXECUTOR_EXIT_CODE":  8,
	"EXECUTOR_STDOUT":     11,
	"EXECUTOR_STDERR":     12,
	"SYSTEM_LOG":          13,
	"TASK_CREATED":        14,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Metadata struct {
	Value map[string]string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Metadata) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

type Outputs struct {
	Value []*tes.OutputFileLog `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *Outputs) Reset()                    { *m = Outputs{} }
func (m *Outputs) String() string            { return proto.CompactTextString(m) }
func (*Outputs) ProtoMessage()               {}
func (*Outputs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Outputs) GetValue() []*tes.OutputFileLog {
	if m != nil {
		return m.Value
	}
	return nil
}

type SystemLog struct {
	Msg    string            `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	Level  string            `protobuf:"bytes,2,opt,name=level" json:"level,omitempty"`
	Fields map[string]string `protobuf:"bytes,3,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SystemLog) Reset()                    { *m = SystemLog{} }
func (m *SystemLog) String() string            { return proto.CompactTextString(m) }
func (*SystemLog) ProtoMessage()               {}
func (*SystemLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SystemLog) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SystemLog) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SystemLog) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Event struct {
	Id        string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Timestamp string `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Event_State
	//	*Event_StartTime
	//	*Event_EndTime
	//	*Event_Outputs
	//	*Event_Metadata
	//	*Event_ExitCode
	//	*Event_Stdout
	//	*Event_Stderr
	//	*Event_SystemLog
	//	*Event_Task
	Data    isEvent_Data `protobuf_oneof:"data"`
	Attempt uint32       `protobuf:"varint,16,opt,name=attempt" json:"attempt,omitempty"`
	Index   uint32       `protobuf:"varint,17,opt,name=index" json:"index,omitempty"`
	Type    Type         `protobuf:"varint,18,opt,name=type,enum=events.Type" json:"type,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isEvent_Data interface {
	isEvent_Data()
}

type Event_State struct {
	State tes.State `protobuf:"varint,3,opt,name=state,enum=tes.State,oneof"`
}
type Event_StartTime struct {
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,oneof"`
}
type Event_EndTime struct {
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,oneof"`
}
type Event_Outputs struct {
	Outputs *Outputs `protobuf:"bytes,6,opt,name=outputs,oneof"`
}
type Event_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,7,opt,name=metadata,oneof"`
}
type Event_ExitCode struct {
	ExitCode int32 `protobuf:"varint,10,opt,name=exit_code,json=exitCode,oneof"`
}
type Event_Stdout struct {
	Stdout string `protobuf:"bytes,13,opt,name=stdout,oneof"`
}
type Event_Stderr struct {
	Stderr string `protobuf:"bytes,14,opt,name=stderr,oneof"`
}
type Event_SystemLog struct {
	SystemLog *SystemLog `protobuf:"bytes,15,opt,name=system_log,json=systemLog,oneof"`
}
type Event_Task struct {
	Task *tes.Task `protobuf:"bytes,19,opt,name=task,oneof"`
}

func (*Event_State) isEvent_Data()     {}
func (*Event_StartTime) isEvent_Data() {}
func (*Event_EndTime) isEvent_Data()   {}
func (*Event_Outputs) isEvent_Data()   {}
func (*Event_Metadata) isEvent_Data()  {}
func (*Event_ExitCode) isEvent_Data()  {}
func (*Event_Stdout) isEvent_Data()    {}
func (*Event_Stderr) isEvent_Data()    {}
func (*Event_SystemLog) isEvent_Data() {}
func (*Event_Task) isEvent_Data()      {}

func (m *Event) GetData() isEvent_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Event) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Event) GetState() tes.State {
	if x, ok := m.GetData().(*Event_State); ok {
		return x.State
	}
	return tes.State_UNKNOWN
}

func (m *Event) GetStartTime() string {
	if x, ok := m.GetData().(*Event_StartTime); ok {
		return x.StartTime
	}
	return ""
}

func (m *Event) GetEndTime() string {
	if x, ok := m.GetData().(*Event_EndTime); ok {
		return x.EndTime
	}
	return ""
}

func (m *Event) GetOutputs() *Outputs {
	if x, ok := m.GetData().(*Event_Outputs); ok {
		return x.Outputs
	}
	return nil
}

func (m *Event) GetMetadata() *Metadata {
	if x, ok := m.GetData().(*Event_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *Event) GetExitCode() int32 {
	if x, ok := m.GetData().(*Event_ExitCode); ok {
		return x.ExitCode
	}
	return 0
}

func (m *Event) GetStdout() string {
	if x, ok := m.GetData().(*Event_Stdout); ok {
		return x.Stdout
	}
	return ""
}

func (m *Event) GetStderr() string {
	if x, ok := m.GetData().(*Event_Stderr); ok {
		return x.Stderr
	}
	return ""
}

func (m *Event) GetSystemLog() *SystemLog {
	if x, ok := m.GetData().(*Event_SystemLog); ok {
		return x.SystemLog
	}
	return nil
}

func (m *Event) GetTask() *tes.Task {
	if x, ok := m.GetData().(*Event_Task); ok {
		return x.Task
	}
	return nil
}

func (m *Event) GetAttempt() uint32 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

func (m *Event) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Event) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_UNKNOWN
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Event_OneofMarshaler, _Event_OneofUnmarshaler, _Event_OneofSizer, []interface{}{
		(*Event_State)(nil),
		(*Event_StartTime)(nil),
		(*Event_EndTime)(nil),
		(*Event_Outputs)(nil),
		(*Event_Metadata)(nil),
		(*Event_ExitCode)(nil),
		(*Event_Stdout)(nil),
		(*Event_Stderr)(nil),
		(*Event_SystemLog)(nil),
		(*Event_Task)(nil),
	}
}

func _Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Event)
	// data
	switch x := m.Data.(type) {
	case *Event_State:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.State))
	case *Event_StartTime:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StartTime)
	case *Event_EndTime:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.EndTime)
	case *Event_Outputs:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Outputs); err != nil {
			return err
		}
	case *Event_Metadata:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case *Event_ExitCode:
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ExitCode))
	case *Event_Stdout:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Stdout)
	case *Event_Stderr:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Stderr)
	case *Event_SystemLog:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SystemLog); err != nil {
			return err
		}
	case *Event_Task:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Task); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Event.Data has unexpected type %T", x)
	}
	return nil
}

func _Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Event)
	switch tag {
	case 3: // data.state
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Event_State{tes.State(x)}
		return true, err
	case 4: // data.start_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_StartTime{x}
		return true, err
	case 5: // data.end_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_EndTime{x}
		return true, err
	case 6: // data.outputs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Outputs)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Outputs{msg}
		return true, err
	case 7: // data.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Metadata{msg}
		return true, err
	case 10: // data.exit_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &Event_ExitCode{int32(x)}
		return true, err
	case 13: // data.stdout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_Stdout{x}
		return true, err
	case 14: // data.stderr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Data = &Event_Stderr{x}
		return true, err
	case 15: // data.system_log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SystemLog)
		err := b.DecodeMessage(msg)
		m.Data = &Event_SystemLog{msg}
		return true, err
	case 19: // data.task
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(tes.Task)
		err := b.DecodeMessage(msg)
		m.Data = &Event_Task{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Event)
	// data
	switch x := m.Data.(type) {
	case *Event_State:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.State))
	case *Event_StartTime:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StartTime)))
		n += len(x.StartTime)
	case *Event_EndTime:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.EndTime)))
		n += len(x.EndTime)
	case *Event_Outputs:
		s := proto.Size(x.Outputs)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_ExitCode:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ExitCode))
	case *Event_Stdout:
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Stdout)))
		n += len(x.Stdout)
	case *Event_Stderr:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Stderr)))
		n += len(x.Stderr)
	case *Event_SystemLog:
		s := proto.Size(x.SystemLog)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Task:
		s := proto.Size(x.Task)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WriteEventResponse struct {
}

func (m *WriteEventResponse) Reset()                    { *m = WriteEventResponse{} }
func (m *WriteEventResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteEventResponse) ProtoMessage()               {}
func (*WriteEventResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func init() {
	proto.RegisterType((*Metadata)(nil), "events.Metadata")
	proto.RegisterType((*Outputs)(nil), "events.Outputs")
	proto.RegisterType((*SystemLog)(nil), "events.SystemLog")
	proto.RegisterType((*Event)(nil), "events.Event")
	proto.RegisterType((*WriteEventResponse)(nil), "events.WriteEventResponse")
	proto.RegisterEnum("events.Type", Type_name, Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EventService service

type EventServiceClient interface {
	WriteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*WriteEventResponse, error)
}

type eventServiceClient struct {
	cc *grpc.ClientConn
}

func NewEventServiceClient(cc *grpc.ClientConn) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) WriteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*WriteEventResponse, error) {
	out := new(WriteEventResponse)
	err := grpc.Invoke(ctx, "/events.EventService/WriteEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EventService service

type EventServiceServer interface {
	WriteEvent(context.Context, *Event) (*WriteEventResponse, error)
}

func RegisterEventServiceServer(s *grpc.Server, srv EventServiceServer) {
	s.RegisterService(&_EventService_serviceDesc, srv)
}

func _EventService_WriteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).WriteEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventService/WriteEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).WriteEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "events.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WriteEvent",
			Handler:    _EventService_WriteEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "events.proto",
}

func init() { proto.RegisterFile("events.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4b, 0x6f, 0xea, 0x46,
	0x14, 0xc6, 0xbc, 0x39, 0x3c, 0x62, 0x4e, 0x6e, 0xdb, 0x11, 0xf7, 0x46, 0x41, 0xac, 0x50, 0x2b,
	0x11, 0x95, 0xa8, 0x52, 0xd2, 0x1d, 0x05, 0xa7, 0x44, 0x09, 0x50, 0xd9, 0x43, 0x93, 0xae, 0x90,
	0x1b, 0x9f, 0x22, 0x2b, 0xf8, 0x21, 0x7b, 0xa0, 0x61, 0xdf, 0xbf, 0xd2, 0xbf, 0xd8, 0x75, 0x35,
	0x63, 0x1b, 0x68, 0xb2, 0xea, 0x8e, 0xef, 0x31, 0xe7, 0xf1, 0x1d, 0x0b, 0x68, 0xd0, 0x8e, 0x7c,
	0x11, 0x0f, 0xc2, 0x28, 0x10, 0x01, 0x96, 0x13, 0xd4, 0xa9, 0x09, 0x4a, 0xa9, 0xce, 0x97, 0x75,
	0x10, 0xac, 0x37, 0x74, 0x65, 0x87, 0xee, 0x95, 0xed, 0xfb, 0x81, 0xb0, 0x85, 0x1b, 0xf8, 0xa9,
	0xda, 0xfb, 0x13, 0xaa, 0x33, 0x12, 0xb6, 0x63, 0x0b, 0x1b, 0xbf, 0x87, 0xd2, 0xce, 0xde, 0x6c,
	0x89, 0x69, 0xdd, 0x42, 0xbf, 0x3e, 0xfc, 0x3c, 0x48, 0x4b, 0x67, 0x86, 0xc1, 0xaf, 0x52, 0x35,
	0x7c, 0x11, 0xed, 0xcd, 0xc4, 0xd9, 0xb9, 0x01, 0x38, 0x92, 0xa8, 0x43, 0xe1, 0x95, 0xf6, 0x4c,
	0xeb, 0x6a, 0xfd, 0x9a, 0x29, 0x7f, 0xe2, 0xa7, 0xac, 0x64, 0x5e, 0x71, 0x09, 0xf8, 0x31, 0x7f,
	0xa3, 0xf5, 0xae, 0xa1, 0xb2, 0xd8, 0x8a, 0x70, 0x2b, 0x62, 0xec, 0xff, 0xb7, 0x2f, 0x0e, 0xe4,
	0xf0, 0x89, 0x78, 0xe7, 0x6e, 0xe8, 0x31, 0x58, 0xa7, 0x0f, 0x7b, 0x7f, 0x6b, 0x50, 0xb3, 0xf6,
	0xb1, 0x20, 0xef, 0x31, 0x58, 0xcb, 0x76, 0x5e, 0xbc, 0xce, 0xda, 0x79, 0xf1, 0x5a, 0xb6, 0xdb,
	0xd0, 0x8e, 0x36, 0x59, 0x3b, 0x05, 0xf0, 0x07, 0x28, 0xff, 0xe1, 0xd2, 0xc6, 0x89, 0x59, 0x41,
	0x35, 0xb8, 0xc8, 0x16, 0x3b, 0x94, 0x1a, 0xdc, 0x29, 0x3d, 0x59, 0x2d, 0x35, 0x77, 0x6e, 0xa1,
	0x7e, 0x42, 0xff, 0xaf, 0xe5, 0xfe, 0x29, 0x40, 0xc9, 0x90, 0x3d, 0xb0, 0x05, 0x79, 0xd7, 0x49,
	0x1f, 0xe5, 0x5d, 0x07, 0xbf, 0x40, 0x4d, 0xb8, 0x1e, 0xc5, 0xc2, 0xf6, 0xc2, 0xf4, 0xdd, 0x91,
	0xc0, 0x1e, 0x94, 0x62, 0x61, 0x0b, 0x62, 0x85, 0xae, 0xd6, 0x6f, 0x0d, 0x41, 0x25, 0x61, 0x49,
	0x66, 0x9a, 0x33, 0x13, 0x09, 0x2f, 0x01, 0x62, 0x61, 0x47, 0x62, 0x25, 0x9f, 0xb1, 0xa2, 0x2c,
	0x31, 0xcd, 0x99, 0x35, 0xc5, 0x71, 0xd7, 0x23, 0xfc, 0x0c, 0x55, 0xf2, 0x9d, 0x44, 0x2e, 0xa5,
	0x72, 0x85, 0x7c, 0x47, 0x89, 0xdf, 0x41, 0x25, 0x48, 0x62, 0x67, 0xe5, 0xae, 0xd6, 0xaf, 0x0f,
	0xcf, 0xb2, 0x30, 0xd2, 0x6b, 0x48, 0x73, 0xea, 0xc0, 0x01, 0x54, 0xbd, 0xf4, 0xf6, 0xac, 0xa2,
	0xdc, 0xfa, 0xfb, 0x6f, 0x62, 0x9a, 0x33, 0x0f, 0x1e, 0xbc, 0x80, 0x1a, 0xbd, 0xb9, 0x62, 0xf5,
	0x12, 0x38, 0xc4, 0xa0, 0xab, 0xf5, 0x4b, 0x52, 0x96, 0xd4, 0x38, 0x70, 0x08, 0x19, 0x94, 0x63,
	0xe1, 0x04, 0x5b, 0xc1, 0x9a, 0xe9, 0x58, 0x29, 0x4e, 0x15, 0x8a, 0x22, 0xd6, 0x3a, 0x51, 0x28,
	0x8a, 0x70, 0x08, 0x10, 0xab, 0x2b, 0xad, 0x36, 0xc1, 0x9a, 0x9d, 0xa9, 0x21, 0xda, 0x1f, 0xee,
	0xa7, 0x02, 0x38, 0x7c, 0x17, 0x97, 0x50, 0x14, 0x76, 0xfc, 0xca, 0xce, 0x95, 0xbb, 0xa6, 0x42,
	0xe4, 0x76, 0xfc, 0x3a, 0xcd, 0x99, 0x4a, 0x40, 0x06, 0x15, 0x5b, 0x08, 0xf2, 0x42, 0xc1, 0xf4,
	0xae, 0xd6, 0x6f, 0x9a, 0x19, 0x94, 0x27, 0x75, 0x7d, 0x87, 0xde, 0x58, 0x5b, 0xf1, 0x09, 0xc0,
	0x2e, 0x14, 0xc5, 0x3e, 0x24, 0x86, 0xea, 0x2a, 0x8d, 0xac, 0x3d, 0xdf, 0x87, 0x64, 0x2a, 0xe5,
	0xa7, 0x32, 0x14, 0x65, 0x02, 0xbd, 0x4f, 0x80, 0x4f, 0x91, 0x2b, 0x48, 0x1d, 0xdf, 0xa4, 0x38,
	0x0c, 0xfc, 0x98, 0xbe, 0xfd, 0x2b, 0x0f, 0x45, 0x69, 0xc6, 0x3a, 0x54, 0x96, 0xf3, 0x87, 0xf9,
	0xe2, 0x69, 0xae, 0xe7, 0xb0, 0x05, 0xc0, 0x47, 0xd6, 0xc3, 0xca, 0xe2, 0x23, 0x6e, 0xe8, 0x1a,
	0x9e, 0xc3, 0x59, 0x86, 0x4d, 0xbe, 0xe2, 0xf7, 0x33, 0x43, 0xcf, 0x63, 0x1b, 0x9a, 0x8a, 0x34,
	0xe6, 0x93, 0x84, 0x2a, 0xa0, 0x0e, 0x0d, 0x45, 0x2d, 0x96, 0xfc, 0x97, 0x25, 0xb7, 0xf4, 0xe2,
	0xc1, 0x34, 0x33, 0xf8, 0x68, 0x32, 0xe2, 0x23, 0xbd, 0x84, 0xdf, 0xc0, 0xb9, 0xf1, 0x6c, 0x8c,
	0x97, 0x7c, 0x61, 0x9e, 0x16, 0x2c, 0xe3, 0x57, 0xd0, 0x3e, 0x08, 0x87, 0xa2, 0x15, 0xfc, 0x1a,
	0xf0, 0x48, 0x3f, 0xdf, 0xf3, 0xd5, 0x78, 0x31, 0x31, 0xf4, 0xaa, 0x1c, 0xea, 0xa4, 0xce, 0x64,
	0xb1, 0xe4, 0x7a, 0xfd, 0x3d, 0x69, 0x98, 0xa6, 0xde, 0x90, 0xeb, 0x58, 0xbf, 0x59, 0xdc, 0x98,
	0xad, 0x1e, 0x17, 0x3f, 0xeb, 0xcd, 0xc3, 0x98, 0x63, 0xd3, 0x18, 0x71, 0x63, 0xa2, 0xb7, 0x86,
	0xf7, 0xd0, 0x50, 0xb9, 0x58, 0x14, 0xed, 0xdc, 0x17, 0xc2, 0x5b, 0x80, 0x63, 0x58, 0xd8, 0xcc,
	0x62, 0x55, 0xb0, 0xd3, 0xc9, 0xe0, 0xc7, 0x3c, 0x7b, 0xb9, 0xdf, 0xcb, 0xea, 0xdf, 0xeb, 0xfa,
	0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x88, 0x54, 0xe1, 0xfa, 0xfe, 0x04, 0x00, 0x00,
}
