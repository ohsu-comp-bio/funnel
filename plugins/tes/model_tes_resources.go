/*
Task Execution Service

## Executive Summary The Task Execution Service (TES) API is a standardized schema and API for describing and executing batch execution tasks. A task defines a set of input files, a set of containers and commands to run, a set of output files and some other logging and metadata.  TES servers accept task documents and execute them asynchronously on available compute resources. A TES server could be built on top of a traditional HPC queuing system, such as Grid Engine, Slurm or cloud style compute systems such as AWS Batch or Kubernetes. ## Introduction This document describes the TES API and provides details on the specific endpoints, request formats, and responses. It is intended to provide key information for developers of TES-compatible services as well as clients that will call these TES services. Use cases include:    - Deploying existing workflow engines on new infrastructure. Workflow engines   such as CWL-Tes and Cromwell have extentions for using TES. This will allow   a system engineer to deploy them onto a new infrastructure using a job scheduling   system not previously supported by the engine.    - Developing a custom workflow management system. This API provides a common   interface to asynchronous batch processing capabilities. A developer can write   new tools against this interface and expect them to work using a variety of   backend solutions that all support the same specification.   ## Standards The TES API specification is written in OpenAPI and embodies a RESTful service philosophy. It uses JSON in requests and responses and standard HTTP/HTTPS for information transport. HTTPS should be used rather than plain HTTP except for testing or internal-only purposes. ### Authentication and Authorization Is is envisaged that most TES API instances will require users to authenticate to use the endpoints. However, the decision if authentication is required should be taken by TES API implementers.  If authentication is required, we recommend that TES implementations use an OAuth2  bearer token, although they can choose other mechanisms if appropriate.  Checking that a user is authorized to submit TES requests is a responsibility of TES implementations. ### CORS If TES API implementation is to be used by another website or domain it must implement Cross Origin Resource Sharing (CORS). Please refer to https://w3id.org/ga4gh/product-approval-support/cors for more information about GA4GHâ€™s recommendations and how to implement CORS. 

API version: 1.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tes

import (
	"encoding/json"
)

// checks if the TesResources type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TesResources{}

// TesResources Resources describes the resources requested by a task.
type TesResources struct {
	// Requested number of CPUs
	CpuCores *int32 `json:"cpu_cores,omitempty"`
	// Define if the task is allowed to run on preemptible compute instances, for example, AWS Spot. This option may have no effect when utilized on some backends that don't have the concept of preemptible jobs.
	Preemptible *bool `json:"preemptible,omitempty"`
	// Requested RAM required in gigabytes (GB)
	RamGb *float64 `json:"ram_gb,omitempty"`
	// Requested disk size in gigabytes (GB)
	DiskGb *float64 `json:"disk_gb,omitempty"`
	// Request that the task be run in these compute zones. How this string is utilized will be dependent on the backend system. For example, a system based on a cluster queueing system may use this string to define priorty queue to which the job is assigned.
	Zones []string `json:"zones,omitempty"`
	// Key/value pairs for backend configuration. ServiceInfo shall return a list of keys that a backend supports. Keys are case insensitive. It is expected that clients pass all runtime or hardware requirement key/values that are not mapped to existing tesResources properties to backend_parameters. Backends shall log system warnings if a key is passed that is unsupported. Backends shall not store or return unsupported keys if included in a task. If backend_parameters_strict equals true, backends should fail the task if any key/values are unsupported, otherwise, backends should attempt to run the task Intended uses include VM size selection, coprocessor configuration, etc. Example: ``` {   \"backend_parameters\" : {     \"VmSize\" : \"Standard_D64_v3\"   } } ```
	BackendParameters *map[string]string `json:"backend_parameters,omitempty"`
	// If set to true, backends should fail the task if any backend_parameters key/values are unsupported, otherwise, backends should attempt to run the task
	BackendParametersStrict *bool `json:"backend_parameters_strict,omitempty"`
}

// NewTesResources instantiates a new TesResources object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTesResources() *TesResources {
	this := TesResources{}
	var backendParametersStrict bool = false
	this.BackendParametersStrict = &backendParametersStrict
	return &this
}

// NewTesResourcesWithDefaults instantiates a new TesResources object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTesResourcesWithDefaults() *TesResources {
	this := TesResources{}
	var backendParametersStrict bool = false
	this.BackendParametersStrict = &backendParametersStrict
	return &this
}

// GetCpuCores returns the CpuCores field value if set, zero value otherwise.
func (o *TesResources) GetCpuCores() int32 {
	if o == nil || IsNil(o.CpuCores) {
		var ret int32
		return ret
	}
	return *o.CpuCores
}

// GetCpuCoresOk returns a tuple with the CpuCores field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetCpuCoresOk() (*int32, bool) {
	if o == nil || IsNil(o.CpuCores) {
		return nil, false
	}
	return o.CpuCores, true
}

// HasCpuCores returns a boolean if a field has been set.
func (o *TesResources) HasCpuCores() bool {
	if o != nil && !IsNil(o.CpuCores) {
		return true
	}

	return false
}

// SetCpuCores gets a reference to the given int32 and assigns it to the CpuCores field.
func (o *TesResources) SetCpuCores(v int32) {
	o.CpuCores = &v
}

// GetPreemptible returns the Preemptible field value if set, zero value otherwise.
func (o *TesResources) GetPreemptible() bool {
	if o == nil || IsNil(o.Preemptible) {
		var ret bool
		return ret
	}
	return *o.Preemptible
}

// GetPreemptibleOk returns a tuple with the Preemptible field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetPreemptibleOk() (*bool, bool) {
	if o == nil || IsNil(o.Preemptible) {
		return nil, false
	}
	return o.Preemptible, true
}

// HasPreemptible returns a boolean if a field has been set.
func (o *TesResources) HasPreemptible() bool {
	if o != nil && !IsNil(o.Preemptible) {
		return true
	}

	return false
}

// SetPreemptible gets a reference to the given bool and assigns it to the Preemptible field.
func (o *TesResources) SetPreemptible(v bool) {
	o.Preemptible = &v
}

// GetRamGb returns the RamGb field value if set, zero value otherwise.
func (o *TesResources) GetRamGb() float64 {
	if o == nil || IsNil(o.RamGb) {
		var ret float64
		return ret
	}
	return *o.RamGb
}

// GetRamGbOk returns a tuple with the RamGb field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetRamGbOk() (*float64, bool) {
	if o == nil || IsNil(o.RamGb) {
		return nil, false
	}
	return o.RamGb, true
}

// HasRamGb returns a boolean if a field has been set.
func (o *TesResources) HasRamGb() bool {
	if o != nil && !IsNil(o.RamGb) {
		return true
	}

	return false
}

// SetRamGb gets a reference to the given float64 and assigns it to the RamGb field.
func (o *TesResources) SetRamGb(v float64) {
	o.RamGb = &v
}

// GetDiskGb returns the DiskGb field value if set, zero value otherwise.
func (o *TesResources) GetDiskGb() float64 {
	if o == nil || IsNil(o.DiskGb) {
		var ret float64
		return ret
	}
	return *o.DiskGb
}

// GetDiskGbOk returns a tuple with the DiskGb field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetDiskGbOk() (*float64, bool) {
	if o == nil || IsNil(o.DiskGb) {
		return nil, false
	}
	return o.DiskGb, true
}

// HasDiskGb returns a boolean if a field has been set.
func (o *TesResources) HasDiskGb() bool {
	if o != nil && !IsNil(o.DiskGb) {
		return true
	}

	return false
}

// SetDiskGb gets a reference to the given float64 and assigns it to the DiskGb field.
func (o *TesResources) SetDiskGb(v float64) {
	o.DiskGb = &v
}

// GetZones returns the Zones field value if set, zero value otherwise.
func (o *TesResources) GetZones() []string {
	if o == nil || IsNil(o.Zones) {
		var ret []string
		return ret
	}
	return o.Zones
}

// GetZonesOk returns a tuple with the Zones field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetZonesOk() ([]string, bool) {
	if o == nil || IsNil(o.Zones) {
		return nil, false
	}
	return o.Zones, true
}

// HasZones returns a boolean if a field has been set.
func (o *TesResources) HasZones() bool {
	if o != nil && !IsNil(o.Zones) {
		return true
	}

	return false
}

// SetZones gets a reference to the given []string and assigns it to the Zones field.
func (o *TesResources) SetZones(v []string) {
	o.Zones = v
}

// GetBackendParameters returns the BackendParameters field value if set, zero value otherwise.
func (o *TesResources) GetBackendParameters() map[string]string {
	if o == nil || IsNil(o.BackendParameters) {
		var ret map[string]string
		return ret
	}
	return *o.BackendParameters
}

// GetBackendParametersOk returns a tuple with the BackendParameters field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetBackendParametersOk() (*map[string]string, bool) {
	if o == nil || IsNil(o.BackendParameters) {
		return nil, false
	}
	return o.BackendParameters, true
}

// HasBackendParameters returns a boolean if a field has been set.
func (o *TesResources) HasBackendParameters() bool {
	if o != nil && !IsNil(o.BackendParameters) {
		return true
	}

	return false
}

// SetBackendParameters gets a reference to the given map[string]string and assigns it to the BackendParameters field.
func (o *TesResources) SetBackendParameters(v map[string]string) {
	o.BackendParameters = &v
}

// GetBackendParametersStrict returns the BackendParametersStrict field value if set, zero value otherwise.
func (o *TesResources) GetBackendParametersStrict() bool {
	if o == nil || IsNil(o.BackendParametersStrict) {
		var ret bool
		return ret
	}
	return *o.BackendParametersStrict
}

// GetBackendParametersStrictOk returns a tuple with the BackendParametersStrict field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TesResources) GetBackendParametersStrictOk() (*bool, bool) {
	if o == nil || IsNil(o.BackendParametersStrict) {
		return nil, false
	}
	return o.BackendParametersStrict, true
}

// HasBackendParametersStrict returns a boolean if a field has been set.
func (o *TesResources) HasBackendParametersStrict() bool {
	if o != nil && !IsNil(o.BackendParametersStrict) {
		return true
	}

	return false
}

// SetBackendParametersStrict gets a reference to the given bool and assigns it to the BackendParametersStrict field.
func (o *TesResources) SetBackendParametersStrict(v bool) {
	o.BackendParametersStrict = &v
}

func (o TesResources) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TesResources) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.CpuCores) {
		toSerialize["cpu_cores"] = o.CpuCores
	}
	if !IsNil(o.Preemptible) {
		toSerialize["preemptible"] = o.Preemptible
	}
	if !IsNil(o.RamGb) {
		toSerialize["ram_gb"] = o.RamGb
	}
	if !IsNil(o.DiskGb) {
		toSerialize["disk_gb"] = o.DiskGb
	}
	if !IsNil(o.Zones) {
		toSerialize["zones"] = o.Zones
	}
	if !IsNil(o.BackendParameters) {
		toSerialize["backend_parameters"] = o.BackendParameters
	}
	if !IsNil(o.BackendParametersStrict) {
		toSerialize["backend_parameters_strict"] = o.BackendParametersStrict
	}
	return toSerialize, nil
}

type NullableTesResources struct {
	value *TesResources
	isSet bool
}

func (v NullableTesResources) Get() *TesResources {
	return v.value
}

func (v *NullableTesResources) Set(val *TesResources) {
	v.value = val
	v.isSet = true
}

func (v NullableTesResources) IsSet() bool {
	return v.isSet
}

func (v *NullableTesResources) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTesResources(val *TesResources) *NullableTesResources {
	return &NullableTesResources{value: val, isSet: true}
}

func (v NullableTesResources) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTesResources) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


